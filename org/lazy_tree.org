#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+EXPORT_FILE_NAME: ../html/lazy_tree.html
#+OPTIONS: broken-links:t
#+TITLE: Lazy trees
Recall that [[foldtree.org][previously]], we used the higher-order function =foldtree= to define functions that operate on trees. My Python code mirrors the code structure in the paper closely, but semantics is different: Because Hughes used a lazy functional language, his code works on lazy trees. With his code, you can generate a tree that is potentially infinite in size, and leave the users of the tree to decide which part of the tree will actually be evaluated. We have seen in the last three chapters that this pattern makes it possible to decompose complex loops into a chain of re-usable components.

Because Python is not a lazy language, we have to incorporate generators/iterators into =foldtree=.

* Representing lazy trees
As in [[foldtree.org][foldtree.org]], a lazy tree is a tuple with a label and a collection of subtrees. For laziness, the subtrees have to be stored in an iterator rather than in a list. Because we will use this structure a lot in the next chapter, I use a named tuple to differentiate a lazy tree from other tuples:
#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  Node = NamedTuple('Node', [('label', Any), ('subtrees', Optional[Iterator])])
#+end_src

Let's build the same tree in [[foldtree.org][foldtree.org]], replacing lists with iterators: 
#+begin_src python :noweb no-export :tangle ../src/test_lazy_tree.py
  <<TEST_LAZY_TREE_IMPORTS>>

  def mk_tree_(label, lst):
      """A throw-away function just for this example"""
      if lst is None:
          return Node(label, None)
      else:
          return Node(label, iter(lst))

  def mk_test_tree():
      my_tree = mk_tree_(1, [
                             mk_tree_(2, None),
                             mk_tree_(3, [mk_tree_(4, None)])
                            ])
      return my_tree
#+end_src

* The higher-order function =foldtree= for lazy trees
This is almost identical to the eager version defined in a [[org/foldtree.org][previous chapter]]. Unfortunately, some modifications are needed, because lists and iterators are manipulated differently in Python.
#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def foldtree(f: Callable, g: Callable, a: Any, t: Union[Node, Iterator, None]):
      """Apply two functions (f and g) of two arguments to transform a lazy tree.
      f: combine the label of a node to its subtrees
      g: combine the subtrees of a node
      a: an initial constant
      t: a tree, a list of subtrees, or []
      """    
      if t is None:
          return a
      elif isinstance(t, tuple):
          (label, subtrees) = t
          return f(label, foldtree(f, g, a, subtrees))
      else:
          try:
              subtree = next(t)
              return g(foldtree(f, g, a, subtree),
                       foldtree(f, g, a, t))
          except StopIteration:
              return a
#+end_src

* Summing all labels in a lazy tree
As before, a variety of lazy tree operations can be implemented with =foldtree=, by using appropriate =f= and =g=.  
#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def sumtree(t: Node) -> int:
      add = operator.add
      return foldtree(add, add, 0, t)
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_lazy_tree.py
  def test_sumtree():
      t = mk_test_tree()
      assert sumtree(t) == 10

      t = mk_test_tree2()
      assert sumtree(t) == sum(range(1, 12))
#+end_src

* Flattening lazy trees
This version of =tree_labels= returns an iterator, which visits every label in the tree one by one:
#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def tree_labels(t: Node) -> Iterator:
      def f(label: Any, folded_subtrees: Iterator) -> Iterator:
          yield label
          for item in folded_subtrees:
              yield item

      def g(folded_first: Iterator, folded_rest: Iterator) -> Iterator:
          for item in folded_first:
              yield item
          for item in folded_rest:
              yield item

      return foldtree(f, g, [], t)
#+end_src

Let's try it. I use =list(t)= to convert the returned iterator to a regular list.
#+begin_src python :noweb yes :tangle ../src/test_lazy_tree.py
  def test_tree_labels():
      t = mk_test_tree()
      i = tree_labels(t)
      assert list(i) == [1, 2, 3, 4]

      t = mk_test_tree2()
      i = tree_labels(t)
      assert list(i) == list(range(1, 12))
#+end_src

* Mapping functions to lazy trees
This version of =maptree= maps a function =f= to all labels in a lazy tree, and returns another lazy tree. 
#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def maptree(func: Callable, t: Node) -> Node:
      def f(label: Any, folded_subtrees: Optional[Iterator]):
          return Node(func(label), folded_subtrees)

      def g(folded_first: Node, folded_rest: Optional[Iterator]) -> Iterator:
          yield folded_first
          if folded_rest is not None:
              for item in folded_rest:
                  yield item

      return foldtree(f, g, None, t)
#+end_src

Let's try it. I use the =tree_labels= function to collect all the labels in the returned lazy tree.
#+begin_src python :noweb yes :tangle ../src/test_lazy_tree.py
  def test_maptree():
      def f(n):
          return -1 * n

      t = mk_test_tree()
      t = maptree(f, t)
      t = tree_labels(t)
      assert list(t) == [-1, -2, -3, -4]

      t = mk_test_tree2()
      res = maptree(lambda x: -1 * x, t)
      res = tree_labels(res)
      assert list(res) == [-1 * i for i in range(1, 12)]
#+end_src

* Size of lazy trees
Here's one more function that we'll use in the [[tic_tac_toe.org][next chapter]]:
#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def tree_size(t: Node) -> int:
      def f(label, folded_subtrees):
          return 1 + folded_subtrees
      return foldtree(f, operator.add, 0, t)
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_lazy_tree.py
  def test_tree_size():
      t = mk_tree_(1, None)
      assert tree_size(t) == 1

      t = mk_test_tree()
      assert tree_size(t) == 4

      t = mk_test_tree2()
      assert tree_size(t) == 11
#+end_src

* Depth of lazy trees
Another utility function:
#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def tree_depth(t: Node) -> int:
      def f(label: Any, folded_subtrees: int):
          return 1 + folded_subtrees
      
      def g(folded_first: int, folded_rest: int) -> int:
          return max(folded_first, folded_rest)

      return foldtree(f, g, 0, t)
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_lazy_tree.py
  def test_tree_depth():
      t = mk_tree_(1, None)
      assert tree_depth(t) == 1

      t = mk_tree_(1, [mk_tree_(2, None)])
      assert tree_depth(t) == 2
    
      t = mk_test_tree()
      assert tree_depth(t) == 3

      t = mk_test_tree2()
      assert tree_depth(t) == 5
#+end_src

* Appendix: imports
#+begin_src python :tangle no :noweb-ref TEST_LAZY_TREE_IMPORTS
  from lazy_utils import *

  def mk_test_tree2():
      my_tree = mk_tree_(1, [
                             mk_tree_(2, [
                                          mk_tree_(3, None),
                                          mk_tree_(4, [
                                                       mk_tree_(5, None),
                                                       mk_tree_(6, [
                                                                    mk_tree_(7, None)
                                                                   ])]),
                                          mk_tree_(8, [mk_tree_(9, None)])
                                         ]),
                             mk_tree_(10, [mk_tree_(11, None)])
                            ])
      return my_tree
#+end_src
