#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+EXPORT_FILE_NAME: ../html/lazy_tree.html
#+TITLE: Lazy trees
Recall that [[foldtree.org][previously]], we used a higher-order function =foldtree= to define functions that operate on trees. My Python codes seem to translate the logic well, but there is a big difference: Because Hughes used a lazy functional language, his code operates on lazy trees, meaning that he could write a function that generates an enormous or even infinite tree, without actually evaluating all the nodes. is very useful for implementing complex algorithms that we will see in the [[tic_tac_toe.org][next chapter]].

Lazy evaluation is not integral to Python, so we have to write some extra codes. I've found it difficult to write a lazy version of the higher-order function =foldtree= in Python, so I will do it less elegantly. Instead of building =treelabels= and =maptree= from a higher-order lazy function, I will just lazify them individually.

* Representing lazy trees
As in [[foldtree.org][foldtree.org]], a lazy tree is a tuple with a label and a collection of subtrees. For laziness, the subtrees have to be stored in an iterator rather than in a list.

Let's build the same tree in [[foldtree.org][foldtree.org]], replacing lists with iterators: 
#+begin_src python :noweb yes :tangle ../src/test_lazy_tree.py
  <<TEST_LAZY_TREE_IMPORTS>>

  def mk_tree_(label, lst):
      """A throw-away function just for this example"""
      if lst is None:
          return (label, None)
      else:
          return (label, iter(lst))

  def mk_test_tree():
      my_tree = mk_tree_(1, [
                             mk_tree_(2, []),
                             mk_tree_(3, [
                                          mk_tree_(4, [])
                                         ]
                              )
                             ])
      return my_tree
#+end_src

* Flattening lazy trees
This version returns an iterator, which visits every label in the tree one by one:

#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def tree_labels(t):
      label, subtrees = t
      yield label
      if subtrees is not None:
          for i in subtrees:
              for j in tree_labels(i):
                  yield j
#+end_src

Let's try it. Note that =tree_labels= is lazy. It returns an iterator. I use =list(t)= to convert it to a regular list.
#+begin_src python :noweb yes :tangle ../src/test_lazy_tree.py
  def test_tree_labels():
      t = mk_test_tree()
      i = tree_labels(t)
      assert list(i) == [1, 2, 3, 4]
#+end_src

* Mapping functions to lazy trees
This version of =maptree= maps a function =f= to all labels in the input, and returns another lazy tree. 
#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def mapforest_(f, forest):
      assert forest is not None
      for t in forest:
          yield maptree(f, t)

  def maptree(f, t):
      label, subtrees = t
      if subtrees is None:
          return (f(label), None)
      else:
          return (f(label), mapforest_(f, subtrees))
#+end_src

Let's try it. I use the =tree_labels= function to collect all the labels in the returned lazy tree.
#+begin_src python :noweb yes :tangle ../src/test_lazy_tree.py
  def test_maptree():
      def f(n):
          return -1 * n

      t = mk_test_tree()
      t = maptree(f, t)
      t = tree_labels(t)
      assert list(t) == [-1, -2, -3, -4]
#+end_src

* Other useful functions
A couple of more functions that we'll use in the [[tic_tac_toe.org][next chapter]].
#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def tree_size(t):
      label, subtrees = t

      if subtrees is None:
          return 1
      else:
          return 1 + sum(map(tree_size, subtrees))
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_lazy_tree.py
  def test_tree_size():
      t = mk_test_tree()
      s = tree_size(t)
      assert s == 4
#+end_src

#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def tree_depth(t):
      def tree_depth_(t, d):
          label, subtrees = t

          if subtrees is None:
              return d
          else:
              try:
                  return max(map(lambda t: tree_depth_(t, d + 1), subtrees))
              except ValueError:
                  print(label, subtrees)

      return tree_depth_(t, 1)
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_lazy_tree.py
  def test_tree_depth():
      t = mk_test_tree()
      d = tree_depth(t)
      assert d == 3
#+end_src

* Appendix: imports
#+begin_src python :tangle no :noweb-ref TEST_LAZY_TREE_IMPORTS
  from lazy_utils import *
#+end_src
