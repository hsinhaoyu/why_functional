#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+EXPORT_FILE_NAME: ../html/tests.html
#+OPTIONS: broken-links:t
* Tic-tac-toe rules
** who_plays()
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_who_plays():
      b = init_board()
      assert who_plays(b) == 0

      b[1] = 0
      assert who_plays(b) == 1
#+end_src

** moves()
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_moves():
      # there should be no legal move for 0 because 1 has already won
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      assert moves(b) is None

      # there should be no legal move for 0 because 0 has already won    
      b = [1, 0, 0, 1, 0, None, None, 0, 1]
      assert moves(b) is None

      # the board is full
      b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
      assert moves(b) is None
#+end_src

** static_eval()
It's important that the static evaluation function knows when a player wins the game:
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_static_eval_winning_condition():
      # evaluate for player 0
      eval_0 = static_eval(0)
      # evaluate for player 1
      eval_1 = static_eval(1)

      # player 0 won
      b = [1, 0, 0, 1, 0, None, None, 0, 1]
      assert eval_0(b) == posinf
      assert eval_1(b) == neginf

      # player 1 won
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      assert eval_0(b) == neginf
      assert eval_1(b) == posinf
#+end_src

* Tic-tac-toe gametree
The winning conditions have to be reflected in the game tree. Let's make sure that they are:
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_game_tree_structure():
      # Since player 0 has won, there should be no subtrees
      b = [1, 0, 0, 1, 0, None, None, 0, 1]
      assert won(b, 0) == True
      t = gametree(b)
      assert t[1] is None

      # Since player 1 has won, there should be no subtrees
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      assert won(b, 1) == True
      t = gametree(b)
      assert t[1] is None

      # This is a draw. There should be no subtrees
      b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
      assert won(b, 0) == False
      assert won(b, 1) == False
      t = gametree(b)
      assert t[1] is None
#+end_src

The static evaluation function, when applied to the game tree, should also reflect the winning conditions.
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_gametree_evaluation():
      # player 0 has won
      b = [1, 0, 0, 1, 0, None, None, 0, 1]
      (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
      assert subtrees is None and score == posinf

      # player 1 has won
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
      assert subtrees is None and score == neginf

      # This is a draw
      b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
      (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
      assert subtrees is None and score == 0
#+end_src

* Alpha-beta pruning
#+begin_src python :noweb yes :tangle ../src/test_alpha_beta.py
  from game import *

  def test_minleq():
      assert minleq(None, 10) == 10

      # not sure if this is the right behavior
      assert minleq(iter([]), 10) == 10

      # looking for a min greater than potential max 5
      itr = iter([7])
      assert minleq(itr, 5) == 7

      # looking for a min greater than potential max 8
      itr = iter([7])
      assert minleq(itr, 8) is True

      # looking for a min greater than potential max 20
      # as soon as we encounter 3, we can stop
      # because the min must be smaller than 3
      itr = iter([3, 2, 5, 10, 1, 6])
      assert minleq(itr, 20) is True

      # looking for a min greater than potential max 10
      itr = iter([3, 2, 5, 10, 1, 6])
      assert minleq(itr, 10) is True

      # looking for a min greater than potential max 1
      itr = iter([3, 2, 5, 10, 1, 6])
      assert minleq(itr, 1) is True

      # looking for a min greater than potential max 0
      # return the min of itr, which can be the new max
      itr = iter([3, 2, 5, 10, 1, 6])
      assert minleq(itr, 0) == 1

  def test_maxgeq():
      assert maxgeq(None, 10) == 10

      # not sure if this is the right behavior
      assert maxgeq(iter([]), 10) == 10

      # looking for a max smaller than potential min 5
      itr = iter([7])
      assert maxgeq(itr, 5) is True

      # looking for a max smaller than potential min 8
      # 7 can be the new min
      itr = iter([7])
      assert maxgeq(itr, 8) == 7

      # looking for a max smaller than potential min 20
      # it is the min of iter 10, which can be the new min
      itr = iter([3, 2, 5, 10, 1, 6])
      assert maxgeq(itr, 20) == 10

      # looking for a max smaller than potential min 10
      # as soon as we found 10, we don't need to go further
      itr = iter([3, 2, 5, 10, 1, 6])
      assert maxgeq(itr, 10) is True


      # looking for a max smaller than potential min 1
      # as soon as we found 3, we don't need to go further    
      itr = iter([3, 2, 5, 10, 1, 6])
      assert maxgeq(itr, 1) is True

      # looking for a max smaller than potential min 0
      # as soon as we found 3, we don't need to go further
      itr = iter([3, 2, 5, 10, 1, 6])
      assert maxgeq(itr, 0) is True

  def test_omit_max():
      seqs = iter([])
      assert list(omit_max(-1, seqs)) == []

      seqs = iter([iter([1])])
      assert list(omit_max(-1, seqs)) == [1]

      seqs = iter([iter([1])])
      assert list(omit_max(3, seqs)) == []

      # not sure if this is the right behavior
      seqs = iter([iter([])])
      assert list(omit_max(3, seqs)) == [3]

      seqs = iter([iter([1, 2]), iter([0, 10]), iter([10, -3])])
      assert list(omit_max(-1, seqs)) == [1]

      seqs = iter([iter([1, 2]), iter([0, 10]), iter([3, 20]), iter([1, 100])])
      assert list(omit_max(-1, seqs)) == [1, 3]

  def test_omit_min():
      seqs = iter([])
      assert list(omit_min(-1, seqs)) == []

      seqs = iter([iter([1])])
      assert list(omit_min(-1, seqs)) == []

      seqs = iter([iter([1])])
      assert list(omit_min(3, seqs)) == [1]

      # not sure if this is the right behavior
      seqs = iter([iter([])])
      assert list(omit_min(3, seqs)) == [3]

      seqs = iter([iter([1, 2]), iter([0, 10]), iter([10, -3])])
      assert list(omit_min(-1, seqs)) == []

      seqs = iter([iter([1, 2]), iter([0, 10]), iter([3, 20]), iter([1, 100])])
      assert list(omit_min(-1, seqs)) == []

  def test_mapmin():
      seqs = iter([iter([1, 2])])
      assert list(mapmin(seqs)) == [1]    

      seqs = iter([iter([1, 2]), iter([0, 10]), iter([10, -3])])
      assert list(mapmin(seqs)) == [1]

      seqs = iter([iter([1, 2]), iter([0, 10]), iter([3, 20]), iter([1, 100])])
      assert list(mapmin(seqs)) == [1, 3]

  def test_mapmax():
      seqs = iter([iter([1, 2])])
      assert list(mapmax(seqs)) == [2]

      seqs = iter([iter([1, 2]), iter([0, 10]), iter([10, -3])])
      assert list(mapmax(seqs)) == [2]

      seqs = iter([iter([1, 2]), iter([0, 10]), iter([3, 20]), iter([1, 100])])
      assert list(mapmax(seqs)) == [2]

#+end_src
