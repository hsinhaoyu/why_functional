#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+EXPORT_FILE_NAME: ../html/foldtree.org
#+TITLE: Higher-order functions for trees

Higher-order functions that operate on iterators should be familiar to many Python programmers. Hughes' paper has a section on =foldr= (which is similar to =functools.reduce= in Python). I'll skip it, and jump directly to an extension of =reduce= that operates on trees.

* Representing trees

I'll represent a tree this way: =(label, [subtree...])=: it's a tuple with a label and a list of subtrees. Note that this is not a binary tree. It's set up this way, because later in his paper, it's used to build game trees.

#+begin_src python :noweb yes :tangle ../src/test_foldtree.py
  from foldtree import *
  
  my_tree = (1, [
                 (2, []),
                 (3, [
                      (4, [])
                     ]
                  )
                 ])
#+end_src

* =foldtree=: =reduce= for trees

To generalize =reduce= to trees, we have to specify two functions (rather than just one, as in =reduce=). The two functions are =f= for combining a label and subtrees, and =g= for combining subtrees. Both are functions of two arguments. =a= is an initializing constant. 

#+begin_src python :noweb yes :tangle ../src/foldtree.py
  import operator


  def foldtree(f, g, a, tree_comp):
      """Apply two functions (f and g) to transform a tree."""
      if tree_comp == []:
          return a
      elif isinstance(tree_comp, list):
          # fold multiple subtrees
          subtree = tree_comp[0]
          rest = tree_comp[1:]
          return g(
                   foldtree(f, g, a, subtree),
                   foldtree(f, g, a, rest))
      else:
          assert isinstance(tree_comp, tuple)
          # fold a label with the subtrees
          (label, subtrees) = tree_comp
          return f(label,
                   foldtree(f, g, a, subtrees))
#+end_src

* Example #1: sum all labels  in a tree

#+begin_src python :noweb yes :tangle ../src/foldtree.py
  def sumtree(tree):
      """Sum all labels in a tree."""
      add = operator.add
      return foldtree(add, add, 0, tree)
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_foldtree.py
  def test_sumtree():
      assert sumtree(my_tree) == 10
#+end_src

* Example #2: tree flattening

Collect all labels of a tree into a list.

#+begin_src python :noweb yes :tangle ../src/foldtree.py
  def tree_labels(tree):
      """Collect all labels of a tree into a list."""
      def cons(label, lst):
          return [label] + lst
      def append(lst1, lst2):
          return lst1 + lst2
      return foldtree(cons, append, [], tree)
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_foldtree.py
  def test_tree_labels():
      assert tree_labels(my_tree) == [1, 2, 3, 4]
#+end_src

* Example #3: =map= for trees

Map a function to all labels in a tree.

#+begin_src python :noweb yes :tangle ../src/foldtree.py
  def maptree(f, tree):
      """Map a function to all labels in a tree"""
      def cons(leaf, lst):
          return [leaf] + lst

      def mk_leaf(leaf, lst):
          return (f(leaf), lst)

      return foldtree(mk_leaf, cons, [], tree)
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_foldtree.py
  def test_maptree():
      res = maptree(lambda x: -1 * x, my_tree)
      res = tree_labels(res)
      assert res == [-1, -2, -3, -4]
#+end_src

