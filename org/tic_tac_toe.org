#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+EXPORT_FILE_NAME: ../html/tic-tac-toe.html
#+TITLE: Play Tic-tac-toe using lazy trees

In this section, we're going to apply the ideas developed so far on a more complicated problem: playing a simple two-person game: Tic-tac-toe. We'll see an elegant implementation of the minimax algorithm using lazy evaluation.

The game itself is not important, so I have moved all Tic-tac-toe specific functions to the end of this chapter. It's sufficient to say that =init_board()= creates an empty 9x9 board, =moves(board)= returns an iterator of all legal configurations for the next move, and we have a pair of functions that use heuristics to score a board configuration. 

#+begin_src python :noweb yes :tangle ../src/tic_tac_toe.py
  <<TIC_TAC_TOE_IMPORTS>>
  <<TIC_TAC_TOE_UTILS>>
  <<TIC_TAC_TOE_EVAL>>
  <<TIC_TAC_TOE_TREE>>
  <<TIC_TAC_TOE_PLAY>>
#+end_src

* Build a (lazy) game tree
Remember that =repeat_f= (defined [[diff.org][here]]) repeatedly maps a function to an initial value to generate a list. =repree= extends the idea to trees. Let =f= be a function that takes a value, and returns a list of values. =reptree= grows a tree out of an initial value by applying =f= repeatedly:

#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def reptree(f, label):
      """Appy a function f to a label repeatedly to create a tree.
      f(label) is a list of labels
      """
      def make_children(lst):
          if lst == None:
              # f produces nothing
              return None
          else:
              # else, apply f repeatedly to elements of lst
              return map(lambda b: reptree(f, b), lst)

      return mk_tree(label, make_children(f(label)))
#+end_src

By applying =moves= repeatedly to a board configuration, we get a tree of all possible future configurations of the game! Of course, =reptree= is lazy, so no future configuration is actually generated. They will only be generated when we access the iterators.
#+begin_src python :noweb yes :tangle ../src/game.py
  <<GAME_IMPORTS>>

  def gametree(moves):
      def gametree_(board):
          return reptree(moves, board)
      return gametree_
#+end_src

Here, we generate all possible Tic-tac-toe games! Let's find out how big it is.
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  <<TEST_TIC_TAC_TOE_IMPORTS>>

  def test_gametree():
      print("\n\n## test_gametree: no pruning")
      b0 = init_board()
      t = gametree(b0)
      d = tree_depth(t)
      print("depth=", d)

  def test_gametree2():
      b0 = init_board()
      t = gametree(b0)
      s = tree_size(t)
      print("size=", s)
#+end_src

* Prune the game tree
We can make a game tree smaller by removing nodes after a certain depth (=n=):

#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def prune(n: int, tree):
      """Remove nodes n levels below in the tree"""

      (board, subtrees) = decompose_tree(tree)
      if n == 0:
          return mk_tree(board, None)
      elif subtrees is None:
          return mk_tree(board, None)
      else:
          return mk_tree(board, map(lambda t: prune(n - 1, t), subtrees))

#+end_src

Let's check the size of the pruned tree:
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_prune():
      print("\n\n## test_prune: after pruning")
      b0 = init_board()
      t = prune(gametree(b0))
      d = tree_depth(t)
      print("depth=", d)
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_prune2():
      b0 = init_board()
      t = prune(gametree(b0))
      s = tree_size(t)
      print("size=", s)
#+end_src

* Apply static evaluation to the game tree
In the appendix, I defined a pair of functions (=static_eval_0=, =static_eval_1=) to score a board configuration. =static_eval_0= scores the configuration for player 0: a positive score means that the board looks good for player 0; a negative score means that it looks bad. =static_eval_1= changes the sign of this score, so that positive is good for player 1, and negative is bad. 

These are static evaluation functions, meaning that they  don't take future moves into account. It's not good enough for making the next move, but it's a good starting point.

Using the =maptree= function defined in a [[lazy_tree.org][previous chapter]], we can score the entire tree. The following shows the distribution of the scores in a pruned tree:

#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_static_eval2():
      """Apply static eval to a game tree"""
      print("\n## test_static_eval2")
      def freq(lst):
          dict = {}
          for i in lst:
              if i in dict:
                  dict[i] = dict[i] + 1
              else:
                  dict[i] = 1
          return dict

      def show_freq(dict):
          k = dict.keys()
          k = sorted(k)
          for kk in k:
              print(f'{kk:10}     {dict[kk]}')

      b0 = init_board()
      t = prune(gametree(b0))
      t = maptree(static_eval(0), t)
      t = list(tree_labels(t))
      show_freq(freq(t))
#+end_src

* Implement the Minimax algorithm
#+begin_src python :noweb yes :tangle ../src/game.py
  def maximize(gametree):
      """The max step of Minimax"""
      (score, subtrees) = gametree

      # if there is no subtree, return the score of the node
      # otherwise, find the max of the min's
      if subtrees is None:
          s = score
      else:
          s = max(map(minimize, subtrees))
      return s

  def minimize(gametree):
      """The min step of Minimax.
      A node in gametree is ((board, score), subtrees)
      Returns (board, score) with the minimal score
      """    
      (score, subtrees) = gametree

      # if there is no subtree, return the score of the node
      # otherwise, find the min of the max's
      if subtrees is None:
          s = score
      else:
          s = min(map(maximize, subtrees))
      return s
#+end_src

This is our first attempt at the tree evaluation function:
#+begin_src python :noweb yes :tangle ../src/game.py
  #def evaluate1(board, moves, eval_func):
  #    """Evaluate a game position for player 1 with Minimax"""
  #    return minimize(maptree(eval_func, prune(5, gametree(moves, board))))    

  def evaluate1(gametree_, eval_, prune_):
      def evaluate_(board):
          return minimize(maptree(eval_, prune_(gametree_(board))))
      return evaluate_
#+end_src

* Appendix 1: Tic-tac-toe utilities
These functions define the Tic-tac-toe game.

#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_UTILS
  ### searching
  max_depth = 5
  
  ### board configuration and geometry
  posinf = 100000
  neginf = -1 * posinf

  num_pos = 9
  line_idx = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]

  def init_board() -> List:
      """Creat an empty board.
      An unoccupied position is represented by None"""
      board = [None for i in range(num_pos)]
      return board

  def board_line(line_idx: List, board: List) -> List:
      """Return a line (one of line_idx) of a board"""
      return [board[i] for i in line_idx]

  def board_lines(board: List) -> List:
      """Return all the lines in a board"""
      return list(map(lambda idx: board_line(idx, board), line_idx))

  def won(board: List, player: int) -> bool:
      """Has player won?"""
      assert player in [0, 1]
      lines = board_lines(board)

      if any(map(lambda l: l.count(player) == 3, lines)):
          return True
      else:
          return False

  ### Moves
  def make_move(board: List, move: int, current_player: int) -> List:
      """Apply a move (0-8) to a board for a player.
      Return a new board.
      """
      new_board = board.copy()
      assert new_board[move] is None
      assert current_player in [0, 1]

      new_board[move] = current_player

      return new_board

  def who_plays(board: List) -> int:
      return board.count(0) - board.count(1)

  def moves(board: List) -> Union[Iterator, None]:
      """Returns an iterator of boards for all legal next moves.
      Player 0 (X) always makes the first move in a game.
      """
      next_player = who_plays(board)
      other_player = (next_player + 1) % 2

      if won(board, other_player):
          # There is no legal move if the game is already won
          return None
      else:
          candidate_moves = [i for i in range(num_pos) if board[i] is None]
          if len(candidate_moves) == 0:
              return None
          else:
              return map(lambda i: make_move(board, i, next_player), candidate_moves)

  ### game I/O
  def display_board(board: List, coordinates = False, displayXO = False) -> None:
      """Display a board"""
      def row(lst):
          return reduce(lambda a, b: a + " "+ b, lst, "")

      if displayXO:
          d = {None: '.', 1: 'O', 0: 'X'}
      else:
          d = {None: '.', 1: '1', 0: '0'}

      zz = list(map(lambda i: d[i], board))
      zz = [zz[i:i+3] for i in range(0, 9, 3)]
      zz = list(map(row, zz))

      if coordinates:
          def d(i):
              if board[i] is None:
                  return str(i)
              else:
                  return "."
          zz2 = [d(i) for i in range(9)]
          zz2 = [zz2[i:i+3] for i in range(0, 9, 3)]
          zz2 = list(map(row, zz2))

      res = ""
      if coordinates:
          for i in range(3):
              res = res + zz[i] + "\t\t" + zz2[i] + "\n"
      else:
          for i in range(3):
              res = res + zz[i] + "\n"

      print(res[:-1])

  def player_input(board: List) -> List:
      """Display current board, ask player to make the next move.
      Return a board after the player's move.
      """
      display_board(board, coordinates = True)
      legal_moves = [i for i in range(9) if board[i] is None]
      ok = False
      while not ok:
          m = input("move?")
          try:
              i = int(m)
              if i in legal_moves:
                  ok = True
          except ValueError:
              pass

      # the human player is always player 0
      return make_move(board, i, 0) 
#+end_src

Some basic testing:
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_who_plays():
      b = init_board()
      assert who_plays(b) == 0

      b[1] = 0
      assert who_plays(b) == 1

      b[2] = 1
      assert who_plays(b) == 0
#+end_src

=moves= is very important because it defines all the legal moves. Some basic testing is needed:
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_moves():
      # there should be no legal move for 0 because 1 has already won
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      assert moves(b) is None

      # there should be no legal move for 0 because 0 has already won    
      b = [1, 0, 0, 1, 0, None, None, 0, 1]
      assert moves(b) is None

      # the board is full
      b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
      assert moves(b) is None
#+end_src

* Appendix 2: A static evaluation function for Tic-tac-toe
A static evaluation function takes a board configuration and returns a number representing how good the position is (without taking future moves into account). There are different ways to evaluate how good a configuration is. I implemented a very common one.

#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_EVAL
  ### Heuristic evaluation of board configurations
  def is_good_line(n: int, player: int, line: List) -> bool:
      """A typical way to evaluate if a line is good"""

      assert n in [1, 2]
      assert player in [0, 1]

      v1 = line.count(player) == n
      v2 = line.count(None) == 3 - n
      return v1 and v2

  def count_good_lines(n: int , player: int, lines: List) -> int:
      """How many good lines?"""

      assert n in [1, 2]
      assert player in [0, 1]

      zz = list(map(lambda l: is_good_line(n, player, l), lines))
      return zz.count(True)

  def static_eval_0(board: List) -> int:
      """Static board value for player 0
      >0: player 0 is doing better
      <0: player 1 is doing better
      """
      lines = board_lines(board)

      if any(map(lambda l: l.count(0) == 3, lines)):
          val = posinf
      elif any(map(lambda l: l.count(1) ==3, lines)):
          val = neginf
      else:
          x2 = count_good_lines(2, 0, lines)
          x1 = count_good_lines(1, 0, lines)

          o2 = count_good_lines(2, 1, lines)
          o1 = count_good_lines(1, 1, lines)

          val = 3 * x2 + x1 - (3 * o2 + o1)
      return val

  def static_eval(i: int) -> Callable[[List], int]:
      """Static board value for player i"""
      assert i in [0, 1]
    
      def static_eval_(board):
          v = static_eval_0(board)
          if i == 0:
              return v
          else:
              return -1 * v
        
      return static_eval_
#+end_src

It's important that the static evaluation function knows when a player wins the game.
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_static_eval_winning_condition():
      # evaluate for player 0
      eval_0 = static_eval(0)
      # evaluate for player 1
      eval_1 = static_eval(1)

      # player 0 won
      b = [1, 0, 0, 1, 0, None, None, 0, 1]
      assert eval_0(b) == posinf
      assert eval_1(b) == neginf

      # player 1 won
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      assert eval_0(b) == neginf
      assert eval_1(b) == posinf
#+end_src

* Appendix 3: Tic-tac-toe gametree structure 
Functions related to game theory (=gametree=, =prune=, =evaluate=) defined in =game.py= are generic, and therefore require a couple of parameters to call. Here, we define Tic-tac-toe specific versions of these functions, to make them easier to call.

#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_TREE
  gametree = game.gametree(moves)

  def prune(tree):
      return lazy_utils.prune(max_depth, tree)

  evaluate1 = game.evaluate1(gametree, static_eval(1), prune)
#+end_src

The winning conditions have to be reflected in the game tree. Let's make sure that they are:
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_game_tree_structure():
      # Since player 0 has won, there should be no subtrees
      b = [1, 0, 0, 1, 0, None, None, 0, 1]
      t = gametree(b)
      assert t[1] is None

      # Since player 1 has won, there should be no subtrees
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      t = gametree(b)
      assert t[1] is None

      # This is a draw. There should be no subtrees
      b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
      t = gametree(b)
      assert t[1] is None
#+end_src

The static evaluation function, when applied to the game tree, should also reflect the winning conditions.
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_gametree_evaluation():
      # player 0 has won
      b = [1, 0, 0, 1, 0, None, None, 0, 1]
      (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
      assert subtrees is None and score == posinf

      # player 1 has won
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
      assert subtrees is None and score == neginf

      # This is a draw
      b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
      (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
      assert subtrees is None and score == 0
#+end_src

* Appendix 4: Testing the tree evaluation function
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_tree_eval():
      b = [1, 0, 0, None, 0, None, 1, None, None]
      print("\nGiven this board, player 1 to play")
      display_board(b)

      print("\nThis move wins")
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      display_board(b)
      score = evaluate1(b)
      assert score == posinf

      print("\nThis move will lose in the next move, so should get a losing score")
      b = [1, 0, 0, None, 0, 1, 1, None, None]
      display_board(b)
      score = evaluate1(b)
      assert score == neginf

      print("\nThis move will win in the next move, so should get a winning score")
      b = [1, 0, 0, None, 0, None, 1, 1, None]
      display_board(b)
      score = evaluate1(b)
      assert score == posinf
#+end_src

* Appendix: Gameplay
#+begin_src python :noweb yes :tangle ../src/game.py
  def ai_next_move(board, moves, eval_):
      """Given a board, return a board with AI's move.
      Note that AI is always player 1.
      """

      (_, subtrees) = gametree(moves, board)

      if subtrees is None:
          return None
      else:
          b, s = None, -1000000
          for next_move in subtrees:
              next_move_board = next_move[0]
              next_move_score = eval_(next_move_board)
              if next_move_score > s:
                  b, s = next_move_board, next_move_score
          return b

#+end_src

#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_PLAY
  def play(tree_eval_func):
      b = init_board()

      finished = False
      while not finished:
          b = player_input(b)
          print()
          print("you played:")
          display_board(b)
          print()

          if won(b, 0):
              print("You've won!")
              finished = True
          else:
              b = ai_next_move(b, moves, tree_eval_func)
              if b is None:
                  print("Draw!")
                  finished = True
              elif won(b, 1):
                  print("computer played: ")
                  display_board(b)
                  print("You've lost!")
                  finished = True
              else:
                  print("computer played:")

  def play1():
      def eval_(board):
          return evaluate1(board, moves, static_eval(1))
      play(eval_)
#+end_src

* Appendix: Imports
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_IMPORTS
  from typing import List, Iterator, Union, Callable
  from functools import reduce
  from lazy_utils import maptree
  import lazy_utils
  import game
  #from game import gametree, maximize, evaluate1, ai_next_move
#+end_src

#+begin_src python :tangle no :noweb-ref GAME_IMPORTS
  from lazy_utils import reptree, mk_tree, decompose_tree, maptree, prune
#+end_src

#+begin_src python :noweb yes :noweb-ref TEST_TIC_TAC_TOE_IMPORTS
  from tic_tac_toe import init_board, moves, static_eval_0, static_eval, display_board, who_plays, posinf, neginf, gametree, prune, evaluate1
  from lazy_utils import tree_size, tree_depth, maptree, tree_labels
#+end_src
