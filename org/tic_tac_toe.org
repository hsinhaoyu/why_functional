#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+EXPORT_FILE_NAME: ../html/tic-tac-toe.html
#+TITLE: Play Tic-Tac-Toe using lazy trees

In this section, we're going to apply the ideas developed so far on a more complicated problem: playing a simple two-person game. We'll see an elegant implementation of the minimax algorithm in the style of lazy evaluation.

#+begin_src python :noweb yes :tangle ../src/tic_tac_toe.py
  <<TIC_TAC_TOE_IMPORTS>>
  <<TIC_TAC_TOE_UTILS>>
  <<TIC_TAC_TOE_EVAL>>
#+end_src

* Build a (lazy) game tree
This is the equivalence of =repeat= for trees.
#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def reptree(f, label):
      """Appy a function f to all labels in a tree repeatedly."""
      return mk_tree(label, map(lambda b: reptree(f, b), f(label)))
#+end_src

#+begin_src python :noweb yes :tangle ../src/game.py
  <<GAME_IMPORTS>>

  def gametree(moves, board):
      return reptree(moves, board)
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  <<TEST_TIC_TAC_TOE_IMPORTS>>

  def test_gametree():
      b0 = init_board()
      t = gametree(moves, b0)
      d = tree_depth(t)
      print("\nBefore pruning:")
      print("depth=", d)

  def test_gametree2():
      b0 = init_board()
      t = gametree(moves, b0)
      s = tree_size(t)
      print("\nBefore pruning:")
      print("size=", s)
#+end_src

* Prune the game tree
#+begin_src python :noweb yes :tangle ../src/game.py
  def prune(n, tree):
      (board, subtrees) = tree
      if n == 0:
          return mk_tree(board, iter([]))
      else:
          return mk_tree(board, map(lambda t: prune(n - 1, t), subtrees))
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_prune():
      b0 = init_board()
      t = prune(4, gametree(moves, b0))
      d = tree_depth(t)
      print("\nAfter pruning:")
      print("depth=", d)
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_prune2():
      b0 = init_board()
      t = prune(5, gametree(moves, b0))
      s = tree_size(t)
      print("\nAfter pruning:")
      print("size=", s)
#+end_src

* Appendix 1: Tic-Tac-Toe utilities
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_UTILS
  num_pos = 9

  def init_board():
      board = [None for i in range(num_pos)]
      return board

  def make_move(board, move: int, current_player: int) -> List:
      new_board = board.copy()
      assert new_board[move] is None

      new_board[move] = current_player

      return new_board

  def moves(board) -> Iterator:
      """Returns an iterator of all legal next moves.
      Player 0 (X) makes the first move in a game.
      """
      next_player = board.count(0) - board.count(1)

      candidate_moves = [i for i in range(num_pos) if board[i] is None]
      return map(lambda i: make_move(board, i, next_player), candidate_moves)

  def display_board(board, coordinates=False):
      def row(lst):
          return reduce(lambda a, b: a + b, lst, "")

      d = {None: '.', 1: 'O', 0: 'X'}
      zz = list(map(lambda i: d[i], board))
      zz = [zz[i:i+3] for i in range(0, 9, 3)]
      zz = list(map(row, zz))

      if coordinates:
          def d(i):
              if board[i] is None:
                  return str(i)
              else:
                  return " "
          zz2 = [d(i) for i in range(9)]
          zz2 = [zz2[i:i+3] for i in range(0, 9, 3)]
          zz2 = list(map(row, zz2))

      res = ""
      if coordinates:
          for i in range(3):
              res = res + zz[i] + "\t" + zz2[i] + "\n"
      else:
          for i in range(3):
              res = res + zz[i] + "\n"

      print(res)

  def player_input(board):
      display_board(board, coordinates = True)
      legal_moves = [i for i in range(9) if board[i] is None]
      ok = False
      while not ok:
          m = input("move?")
          try:
              i = int(m)
              if i in legal_moves:
                  ok = True
          except ValueError:
              pass

      # the human player is always player 0
      return make_move(board, i, 0) 
#+end_src

* Appendix 2: A static evaluation function for Tic-Tac-Toe
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_EVAL
  line_idx = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]

  def board_line(line_idx, board):
      return [board[i] for i in line_idx]

  def board_lines(board):
      return list(map(lambda idx: board_line(idx, board), line_idx))

  def is_good_line(n, player, line):
      v1 = line.count(player) == n
      v2 = line.count(None) == 3 - n
      return v1 and v2

  def count_good_lines(n, player, lines):
      zz = list(map(lambda l: is_good_line(n, player, l), lines))
      return zz.count(True)

  def player0_wins(board):
      lines = board_lines(board)
      return any(map(lambda l: l.count(0) == 3, lines))

  def static_eval(board):
      """Static board value.
      >0: player 0 is doing better
      <0: player 1 is doing better
      """
      lines = board_lines(board)

      if any(map(lambda l: l.count(0) == 3, lines)):
          val = 1000000
      elif any(map(lambda l: l.count(1) ==3, lines)):
          val = -1000000
      else:
          x2 = count_good_lines(2, 0, lines)
          x1 = count_good_lines(1, 0, lines)

          o2 = count_good_lines(2, 1, lines)
          o1 = count_good_lines(1, 1, lines)

          val = 3 * x2 + x1 - (3 * o2 + o1)
      return val
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_static_eval():
      b0 = init_board()
      b0[4] = 0
      print(b0)

      v = static_eval(b0)
      print(v)
#+end_src

* Appendix 3: imports
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_IMPORTS
  from typing import List, Iterator
  from functools import reduce
#+end_src


#+begin_src python :tangle no :noweb-ref GAME_IMPORTS
  from lazy_utils import reptree, mk_tree
#+end_src

#+begin_src python :noweb yes :noweb-ref TEST_TIC_TAC_TOE_IMPORTS
  from tic_tac_toe import init_board, moves, static_eval
  from game import gametree, prune
  from lazy_utils import tree_size, tree_depth
#+end_src
