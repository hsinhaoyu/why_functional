#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+EXPORT_FILE_NAME: ../html/tic-tac-toe.html
#+OPTIONS: broken-links:t
#+TITLE: Let's play Tic-tac-toe
This chapter uses the game AI code developed in the [[org/game.org][previous chapter]] to play Tic-tac-toe. To play the game, run =tic_tac_toe.play()=. This part is not in Hughes' paper.

#+begin_src python :noweb no-export :tangle ../src/tic_tac_toe.py
  <<TIC_TAC_TOE_IMPORTS>>
  <<TIC_TAC_TOE_RULES>>
  <<TIC_TAC_TOE_TREE>>
  <<TIC_TAC_TOE_STATIC>>
  <<TIC_TAC_TOE_MINIMAX>>
  <<TIC_TAC_TOE_PLAY>>
#+end_src

* The Tic-tac-toe game board
These functions define the Tic-tac-toe game world:
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_RULES
  ### gameplay options
  use_player_token = True
  shuffle_moves = False
  max_depth = 5

  posinf = 100000
  neginf = -1 * posinf

  num_pos = 9
  line_idx = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]

  # Cell is a type alias for representing the state of a cell in a board
  Cell = Optional[int]
  # Board is a type alias for representing board configurations
  Board = List[Cell]

  def init_board() -> Board:
      """Creat an empty board.
      An unoccupied position is represented by None"""
      board: List[Optional[int]] = [None for i in range(num_pos)]
      return board

  def board_line(line_idx: List[int], board: Board) -> List[Cell]:
      """Return a line (one of line_idx) of a board"""
      return [board[i] for i in line_idx]

  def board_lines(board: Board) -> List[List[Cell]]:
      """Return all the lines in a board"""
      return list(map(lambda idx: board_line(idx, board), line_idx))

  def won(board: Board, player: int) -> bool:
      """Has player won?"""
      assert player in [0, 1]
      lines = board_lines(board)

      if any(map(lambda l: l.count(player) == 3, lines)):
          return True
      else:
          return False

  def who_plays(board: Board) -> int:
      """Which player is playing the next move?"""
      return board.count(0) - board.count(1)
#+end_src

Note that the player who plays the next move is not stored as a game state, because it can easily be inferred from the game board by =who_plays=.
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_who_plays():
      b = init_board()
      assert who_plays(b) == 0

      b[1] = 0
      assert who_plays(b) == 1
#+end_src

* Legal moves
The function =moves= encapsulates the legal moves of Tic-tac-toe. Given a board configuration, =moves= returns an iterator of board configurations associated with the legal next moves.
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_RULES
  def make_move(board: Board, move: int, current_player: int) -> Board:
      """Apply a move (0-8) to a board for a player.
      Return a new board.
      """
      new_board = board.copy()
      assert new_board[move] is None
      assert current_player in [0, 1]

      new_board[move] = current_player

      return new_board

  def moves(board: Board) -> Optional[Iterator[Board]]:
      """Returns an iterator of boards for all legal next moves."""
      next_player = who_plays(board)
      other_player = (next_player + 1) % 2

      if won(board, other_player):
          # There is no legal move if the game is already won
          return None
      else:
          candidate_moves = [i for i in range(num_pos) if board[i] is None]

          if shuffle_moves:
              shuffle(candidate_moves)

          if len(candidate_moves) == 0:
              return None
          else:
              return map(lambda i: make_move(board, i, next_player), candidate_moves)
#+end_src

Simple tests to make sure that =moves= knows it when no legal moves are available.
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_moves():
      # there should be no legal move for 0 because 1 has already won
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      assert moves(b) is None

      # there should be no legal move for 0 because 0 has already won    
      b = [1, 0, 0, 1, 0, None, None, 0, 1]
      assert moves(b) is None

      # A draw. the board is full
      b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
      assert moves(b) is None
#+end_src

* The Tic-tac-toe game tree
In the previous chapter, we defined generic =gametree= and =prune=. Here, we customize them for Tic-tac-toe:
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_TREE
  gametree: Callable[[Board], Node] = game.gametree(moves)

  def prune(tree: Node) -> Node:
      return lazy_utils.prune(max_depth, tree)
#+end_src

With these, we can generate all possible Tic-tac-toe games! Let's find out how big the tree is.
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>

  d = tree_depth(gametree(init_board()))
  print("depth=", d)
  n = tree_size(gametree(init_board()))
  print("number of nodes=", n)
#+end_src

#+RESULTS:
: depth= 10
: number of nodes= 549946

For playing Tic-tac-toe, we set a limit to the depth of the game tree to =max_depth=, which is set to 5. Let's check the size of the pruned tree:
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_prune():
      print("\n\n## test_prune: after pruning")
      b0 = init_board()
      t = prune(gametree(b0))
      d = tree_depth(t)
      print("depth=", d)
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_prune2():
      b0 = init_board()
      t = prune(gametree(b0))
      s = tree_size(t)
      print("size=", s)
#+end_src

The winning conditions have to be reflected in the game tree. Let's make sure that they are:
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_game_tree_structure():
      # Since player 0 has won, there should be no subtrees
      b = [1, 0, 0, 1, 0, None, None, 0, 1]
      assert won(b, 0) == True
      t = gametree(b)
      assert t[1] is None

      # Since player 1 has won, there should be no subtrees
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      assert won(b, 1) == True
      t = gametree(b)
      assert t[1] is None

      # This is a draw. There should be no subtrees
      b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
      assert won(b, 0) == False
      assert won(b, 1) == False
      t = gametree(b)
      assert t[1] is None
#+end_src

* Static evaluation
A static evaluation function takes a board configuration and returns a number representing how good the position is (without taking future moves into account). There are different ways to evaluate how good a Tic-tac-toe configuration is. I implemented a common one in  =static_eval(player)=. For a given =player=, the function evaluates if the configuration "looks good". A positive number means that the configuration is good for =player=. A negative number means that it's good for the other player.
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_STATIC
  ### Heuristic evaluation of board configurations
  def is_good_line(n: int, player: int, line: List[Cell]) -> bool:
      """A typical way to evaluate if a line is good"""

      assert n in [1, 2]
      assert player in [0, 1]

      v1 = line.count(player) == n
      v2 = line.count(None) == 3 - n
      return v1 and v2

  def count_good_lines(n: int , player: int, lines: List[List[Cell]]) -> int:
      """How many good lines?"""

      assert n in [1, 2]
      assert player in [0, 1]

      zz = list(map(lambda l: is_good_line(n, player, l), lines))
      return zz.count(True)

  def static_eval_0(board: Board) -> int:
      """Static board value for player 0
      >0: player 0 is doing better
      <0: player 1 is doing better
      """
      lines = board_lines(board)

      if any(map(lambda l: l.count(0) == 3, lines)):
          val = posinf
      elif any(map(lambda l: l.count(1) ==3, lines)):
          val = neginf
      else:
          x2 = count_good_lines(2, 0, lines)
          x1 = count_good_lines(1, 0, lines)

          o2 = count_good_lines(2, 1, lines)
          o1 = count_good_lines(1, 1, lines)

          val = 3 * x2 + x1 - (3 * o2 + o1)
      return val

  def static_eval(i: int) -> Callable[[Board], int]:
      """Static board value for player i"""
      assert i in [0, 1]

      def static_eval_(board):
          v = static_eval_0(board)
          if i == 0:
              return v
          else:
              return -1 * v

      return static_eval_
#+end_src

It's important that the static evaluation function knows when a player wins the game:
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_static_eval_winning_condition():
      # evaluate for player 0
      eval_0 = static_eval(0)
      # evaluate for player 1
      eval_1 = static_eval(1)

      # player 0 won
      b = [1, 0, 0, 1, 0, None, None, 0, 1]
      assert eval_0(b) == posinf
      assert eval_1(b) == neginf

      # player 1 won
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      assert eval_0(b) == neginf
      assert eval_1(b) == posinf
#+end_src

* Score the game tree
Using the =maptree= function defined in a [[lazy_tree.org][previous chapter]] to apply the static evaluation function to every node in the game tree, we can score an entire game!

Instead of replacing each label in the game tree with a score, I want to keep the board configuration as well. So let's define a new version of =static_eval= that returns a state object. The =State= class defined below implements methods for numerical comparisons, so the Minimax-related functions defined in the previous chapter can treat a State as if it were an integer.
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_STATIC
  @dataclass
  class State:
      board: Board
      score: int

      def __eq__(self, other):
          return self.score == other.score
      def __gt__(self, other):
          return self.score > other.score
      def __ge__(self, othre):
          return self.score >= other.score
      def __lt__(self, other):
          return self.score < other.score
      def __le__(self, other):
          return self.score <= other.score
#+end_src

This is the static evaluation function that returns a State:
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_STATIC
  def static_eval_state(i: int) -> Callable[[Board], State]:
      """Static board state for player i"""
      assert i in [0, 1]
      score_func = static_eval(i)
    
      def static_eval_(board):
          return State(board, score_func(board))

      return static_eval_
#+end_src

The following shows the distribution of the scores in a pruned tree:
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_static_eval():
      """Apply static eval to a game tree"""
      print("\n## test_static_eval2")
      def freq(lst):
          dict = {}
          for i in lst:
              if i in dict:
                  dict[i] = dict[i] + 1
              else:
                  dict[i] = 1
          return dict

      def show_freq(dict):
          k = dict.keys()
          k = sorted(k)
          for kk in k:
              print(f'{kk:10}     {dict[kk]}')

      b0 = init_board()
      t = prune(gametree(b0))
      t = maptree(static_eval_state(0), t)
      t = tree_labels(t) # collect all the states from the tree
      t = list(map(lambda s: s.score, t)) # extract just the scores 
      show_freq(freq(t))
#+end_src

The static evaluation function, when applied to the game tree, should reflect winning conditions.
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_gametree_evaluation():
      # player 0 has won
      b = [1, 0, 0, 1, 0, None, None, 0, 1]
      (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
      assert subtrees is None and score == posinf

      # player 1 has won
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
      assert subtrees is None and score == neginf

      # This is a draw
      b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
      (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
      assert subtrees is None and score == 0
#+end_src

* Minimax
Here's the first move evaluation function, based on just Minimax:
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_MINIMAX
  # given a player, returns a tree evlauation function
  def evaluate1(player: int) -> Callable[[Board], State]:
      """Evaluate tic-tac-toe tree for player i (version 1)"""
      return game.evaluate1(gametree, static_eval_state(player), prune)
#+end_src

Let's try it on the most basic conditions:
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_tree_eval():
      print("## test_tree_eval()")
      b = [1, 0, 0, None, 0, None, 1, None, None]
      print("\nGiven this board, player 1 (O) to play")
      player = 1
      display_board(b)

      best_move = evaluate1(player)(b)
      print()
      print("O's best move:")
      display_board(best_move.board)

      # player 1 should be able to win the game in one move
      # so the score should be the winning score
      assert best_move.score == posinf

  #@pytest.mark.skip(reason="skip skip skip")    
#+end_src

* Gameplay
Simple utilities for displaying the game board and for handling human player moves:
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_PLAY
  def player_token(i: int) -> str:
      assert i in [0, 1]
      if use_player_token:
          return "X" if i == 0 else "O"
      else:
          return "0" if i== 0 else "1"

  def display_board(board: Board, coordinates = False) -> None:
      """Display a board"""
      def row(lst):
          return reduce(lambda a, b: a + " "+ b, lst, "")

      d = {None: '.', 1: player_token(1), 0: player_token(0)}

      zz = list(map(lambda i: d[i], board))
      zz = [zz[i:i+3] for i in range(0, 9, 3)]
      zz = list(map(row, zz))

      if coordinates:
          def d_(i):
              if board[i] is None:
                  return str(i)
              else:
                  return "."
          zz2 = [d_(i) for i in range(9)]
          zz2 = [zz2[i:i+3] for i in range(0, 9, 3)]
          zz2 = list(map(row, zz2))

      res = ""
      if coordinates:
          for i in range(3):
              res = res + zz[i] + "\t\t" + zz2[i] + "\n"
      else:
          for i in range(3):
              res = res + zz[i] + "\n"

      print(res[:-1])

  def human_next_move(board: Board) -> Optional[Board]:
      """Display current board, ask player to make the next move.
      Return a board after the player's move.
      """
      display_board(board, coordinates = True)
      legal_moves = [i for i in range(num_pos) if board[i] is None]
      if legal_moves == []:
          return None
      else:
          player = who_plays(board)

          ok = False
          while not ok:
              m = input(f"player {player_token(player)} move?")
              try:
                  i = int(m)
                  if i in legal_moves:
                      ok = True
              except ValueError:
                  pass

          return make_move(board, i, player) 
#+end_src

This let a player make a move. A player can be human or computer.
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_PLAY
  def computer_next_move(board: Board, eval_func: Callable[[int],Callable[[Board], State]]) -> Optional[Board]:
      player = who_plays(board)
      computer_move_function = eval_func(player)
      # computer_move_function is a State
      return computer_move_function(board).board

  def player_next_move(board: Board, player_settings = {0: 'human', 1: 'computer'}, eval_func = evaluate1) -> Optional[Board]:
      player = who_plays(board)
      if player_settings[player] == 'human':
          return human_next_move(board)
      else:
          return computer_next_move(board, eval_func)
#+end_src

The main game loop:
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_PLAY
  def play(player_settings = {0: 'human', 1: 'computer'}, eval_func = evaluate1) -> None:
      b = init_board()

      finished = False
      while not finished:
          b = player_next_move(b, player_settings, eval_func)
          player = (who_plays(b) + 1) % 2
          print()
          print(f"{player_token(player)} played:")
          display_board(b)
          print()

          assert b is not None
          if won(b, player):
              print(f"{player_token(player)} won!")
              finished = True
          elif len([i for i in range(num_pos) if b[i] is None]) == 0:
              print("Draw!")
              finished = True  
#+end_src
* Imports
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_IMPORTS
  from typing import List, Iterator, Callable, Optional
  from functools import reduce
  from random import shuffle
  from dataclasses import dataclass 

  from lazy_utils import Node
  import lazy_utils
  import game
#+end_src

#+begin_src python :tangle no :noweb-ref TEST_TIC_TAC_TOE_IMPORTS
  from tic_tac_toe import init_board, moves, static_eval, display_board
  from tic_tac_toe import who_plays, posinf, neginf, gametree, prune, evaluate1, won
  from tic_tac_toe import static_eval_state
  from lazy_utils import tree_size, tree_depth, maptree, tree_labels
  import pytest
#+end_src

#+begin_src python :tangoe no :noweb-ref DEMO_IMPORTS
  from tic_tac_toe import init_board, gametree, prune
  from lazy_utils import tree_size, tree_depth
#+end_src
