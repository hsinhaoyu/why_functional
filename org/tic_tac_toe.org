#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+EXPORT_FILE_NAME: ../html/tic-tac-toe.html
#+TITLE: Play Tic-tac-toe using lazy trees

In this section, we're going to apply the ideas developed so far on a more complicated problem: playing a simple two-person game: Tic-tac-toe. We'll see an elegant implementation of the minimax algorithm using lazy evaluation.

The game itself is not important, so I have moved all Tic-tac-toe specific functions to the end of this chapter. It's sufficient to say that =init_board()= creates an empty 9x9 board, =moves(board)= returns an iterator of all legal configurations for the next move, and we have a pair of functions that use heuristics to score a board configuration. 

#+begin_src python :noweb yes :tangle ../src/tic_tac_toe.py
  <<TIC_TAC_TOE_IMPORTS>>
  <<TIC_TAC_TOE_UTILS>>
  <<TIC_TAC_TOE_EVAL>>
#+end_src

* Build a (lazy) game tree
Remember that =repeat_f= (defined [[diff.org][here]]) repeatedly maps a function to an initial value to generate a list. =repree= extends the idea to trees. Let =f= be a function that takes a value, and returns a list of values. =reptree= grows a tree out of an initial value by applying =f= repeatedly:

#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def reptree(f, label):
      """Appy a function f to a label repeatedly to create a tree."""
      return mk_tree(label, map(lambda b: reptree(f, b), f(label)))
#+end_src

By applying =moves= repeatedly to a board configuration, we get a tree of all possible future configurations of the game! Of course, =reptree= is lazy, so no future configuration is actually generated. They will only be generated when we access the iterators.

#+begin_src python :noweb yes :tangle ../src/game.py
  <<GAME_IMPORTS>>

  def gametree(moves, board):
      return reptree(moves, board)
#+end_src

Here, we generate all possible Tic-tac-toe games! Let's find out how big it is.

#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  <<TEST_TIC_TAC_TOE_IMPORTS>>

  def test_gametree():
      print("\n\n## test_gametree: no pruning")
      b0 = init_board()
      t = gametree(moves, b0)
      d = tree_depth(t)
      print("depth=", d)

  def test_gametree2():
      b0 = init_board()
      t = gametree(moves, b0)
      s = tree_size(t)
      print("size=", s)
#+end_src

* Prune the game tree
We can make a game tree smaller by removing nodes after a certain depth (=n=):

#+begin_src python :noweb yes :tangle ../src/game.py
  def prune(n: int, tree):
      (board, subtrees) = tree
      if n == 0:
          return mk_tree(board, iter([]))
      else:
          return mk_tree(board, map(lambda t: prune(n - 1, t), subtrees))
#+end_src

Let's check the size of the pruned tree:

#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_prune():
      print("\n\n## test_prune: after pruning")
      b0 = init_board()
      t = prune(5, gametree(moves, b0))
      d = tree_depth(t)
      print("depth=", d)
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_prune2():
      b0 = init_board()
      t = prune(5, gametree(moves, b0))
      s = tree_size(t)
      print("size=", s)
#+end_src

* Apply static evaluation to the game tree
In the appendix, I defined a pair of functions (=static_eval_0=, =static_eval_1=) to score a board configuration. =static_eval_0= scores the configuration for player 0: a positive score means that the board looks good for player 0; a negative score means that it looks bad. =static_eval_1= changes the sign of this score, so that positive is good for player 1, and negative is bad. 

These are static evaluation functions, meaning that they  don't take future moves into account. It's not good enough for making the next move, but it's a good starting point.

Here's an example:

#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_static_eval():
      """Apply static eval to one board"""
      print("\n## test_static_eval()")
      b0 = init_board()
      b0[4] = 0
      b0[5] = 1
      print()
      display_board(b0)

      v = static_eval_0(b0)
      print("score for player 0:", v)
#+end_src

Using the =maptree= function defined in a [[lazy_tree.org][previous chapter]], we can score the entire tree. The following shows the distribution of the scores in a pruned tree:

#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_static_eval2():
      """Apply static eval to a game tree"""
      print("\n## test_static_eval2")
      def freq(lst):
          dict = {}
          for i in lst:
              if i in dict:
                  dict[i] = dict[i] + 1
              else:
                  dict[i] = 1
          return dict

      def show_freq(dict):
          k = dict.keys()
          k = sorted(k)
          for kk in k:
              print(f'{kk:10}     {dict[kk]}')

      b0 = init_board()
      t = prune(5, gametree(moves, b0))
      t = maptree(static_eval_0, t)
      t = list(tree_labels(t))
      show_freq(freq(t))
#+end_src

* Implement the Minimax algorithm

#+begin_src python :noweb yes :tangle ../src/game.py
  def maximize(gametree, depth):
      """The max step of Minimax"""
      ((board, score), subtrees) = gametree

      # if there is no subtree, return the score of the node
      # otherwise, find the max of the min's
      b, s = None, -100000
      for subtree in subtrees:
          ((board_, _), _) = subtree
          _, min_s = minimize(subtree, depth + 1)
          if min_s > s:
              b, s = board_, min_s

      if s == -100000:
          b, s = board, score

      if depth == 1:
          return b, s
      else:
          return None, s

  def minimize(gametree, depth):
      """The min step of Minimax.
      A node in gametree is ((board, score), subtrees)
      Returns (board, score) with the minimal score
      """    
      ((board, score), subtrees) = gametree

      # if there is no subtree, return the score of the node
      # otherwise, find the min of the max's
      #b, s = board, score
      #for (_, s_) in map(maximize, subtrees):
      #    if s_ < s:
      #        s = s_

      #return (b, s)
      b, s = None, 100000
      for subtree in subtrees:
          ((board_, _), _) = subtree
          _, max_s = maximize(subtree, depth + 1)
          if max_s < s:
              b, s = board_, max_s

      if s == 100000:
          b, s = board, score

      if depth == 1:
          return b, s
      else:
          return None, s
#+end_src

This is our first attempt at finding the next move:

#+begin_src python :noweb yes :tangle ../src/game.py
  def evaluate1(board, moves, eval_func):
      """Evaluate a game position for player 1 with Minimax"""
      def maximize_(tree):
          return maximize(tree, 1)
      def eval_(board):
          return (board, eval_func(board))
    
      return maximize_(maptree(eval_, prune(5, gametree(moves, board))))
#+end_src

* Let's play Tic-tac-toe
#+begin_src python :noweb yes :tangle ../src/tic_tac_toe.py
  def tic_tac_toe1():
      b = init_board()

      while True:
          b = player_input(b)
          print("you played")
          display_board(b)
          print(f"your score: {static_eval_0(b)}")

          b, s = evaluate1(b, moves, static_eval_1)
          display_board(b)
          print(f"computer score: {s}")
#+end_src

* Appendix 1: Tic-tac-toe utilities
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_UTILS
  num_pos = 9

  def init_board() -> List:
      """Creat an empty board.
      An unoccupied position is represented by None"""
      board = [None for i in range(num_pos)]
      return board

  def make_move(board: List, move: int, current_player: int) -> List:
      """Apply a move (0-8) to a board for a player""" 
      new_board = board.copy()
      assert new_board[move] is None
      assert current_player in [0, 1], "err current_player:" + str(current_player)

      new_board[move] = current_player

      return new_board

  def moves(board: List) -> Iterator:
      """Returns an iterator of boards for all legal next moves.
      Player 0 (X) always makes the first move in a game.
      """
      next_player = board.count(0) - board.count(1)

      candidate_moves = [i for i in range(num_pos) if board[i] is None]
      return map(lambda i: make_move(board, i, next_player), candidate_moves)

  def display_board(board: List, coordinates=False) -> None:
      """Display a board"""
      def row(lst):
          return reduce(lambda a, b: a + " "+ b, lst, "")

      d = {None: '.', 1: 'O', 0: 'X'}
      zz = list(map(lambda i: d[i], board))
      zz = [zz[i:i+3] for i in range(0, 9, 3)]
      zz = list(map(row, zz))

      if coordinates:
          def d(i):
              if board[i] is None:
                  return str(i)
              else:
                  return " "
          zz2 = [d(i) for i in range(9)]
          zz2 = [zz2[i:i+3] for i in range(0, 9, 3)]
          zz2 = list(map(row, zz2))

      res = ""
      if coordinates:
          for i in range(3):
              res = res + zz[i] + "\t" + zz2[i] + "\n"
      else:
          for i in range(3):
              res = res + zz[i] + "\n"

      print(res)

  def player_input(board: List) -> List:
      """Display current board, ask player to make the next move.
      Return a board after the player's move.
      """
      display_board(board, coordinates = True)
      legal_moves = [i for i in range(9) if board[i] is None]
      ok = False
      while not ok:
          m = input("move?")
          try:
              i = int(m)
              if i in legal_moves:
                  ok = True
          except ValueError:
              pass

      # the human player is always player 0
      return make_move(board, i, 0) 
#+end_src

* Appendix 2: A static evaluation function for Tic-tac-toe
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_EVAL
  ########## Hueristic evaluation of board configurations

  line_idx = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]

  def board_line(line_idx: List, board: List) -> List:
      """Return a line (one of line_idx) of a board"""
      return [board[i] for i in line_idx]

  def board_lines(board: List) -> List:
      """"Return all lines of a board"""
      return list(map(lambda idx: board_line(idx, board), line_idx))

  def is_good_line(n: int, player: int, line: List) -> bool:
      """A typical way to evaluate if a line is good"""

      assert n in [1, 2]
      assert player in [0, 1]

      v1 = line.count(player) == n
      v2 = line.count(None) == 3 - n
      return v1 and v2

  def count_good_lines(n: int , player: int, lines: List) -> int:
      """How many good lines?"""

      assert n in [1, 2]
      assert player in [0, 1]

      zz = list(map(lambda l: is_good_line(n, player, l), lines))
      return zz.count(True)

  def static_eval_0(board):
      """Static board value for player 0
      >0: player 0 is doing better
      <0: player 1 is doing better
      """
      lines = board_lines(board)

      if any(map(lambda l: l.count(0) == 3, lines)):
          val = 1000000
      elif any(map(lambda l: l.count(1) ==3, lines)):
          val = -1000000
      else:
          x2 = count_good_lines(2, 0, lines)
          x1 = count_good_lines(1, 0, lines)

          o2 = count_good_lines(2, 1, lines)
          o1 = count_good_lines(1, 1, lines)

          val = 3 * x2 + x1 - (3 * o2 + o1)
      return val

  def static_eval_1(board):
      """Static board value for player 1
      >0: player 1 is doing better
      <0: player 0 is doing better
      """
      return -1 * static_eval_0(board)
#+end_src

* Appendix 3: imports
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_IMPORTS
  from typing import List, Iterator
  from functools import reduce
  from lazy_utils import maptree
  from game import gametree, maximize, prune, evaluate1
#+end_src

#+begin_src python :tangle no :noweb-ref GAME_IMPORTS
  from lazy_utils import reptree, mk_tree, decompose_tree, maptree
#+end_src

#+begin_src python :noweb yes :noweb-ref TEST_TIC_TAC_TOE_IMPORTS
  from tic_tac_toe import init_board, moves, static_eval, display_board
  from game import gametree, prune
  from lazy_utils import tree_size, tree_depth, maptree, tree_labels
#+end_src
