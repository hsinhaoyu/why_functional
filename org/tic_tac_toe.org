#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+EXPORT_FILE_NAME: ../html/tic-tac-toe.html
#+TITLE: Play Tic-tac-toe using lazy trees

In this section, we're going to apply the ideas developed so far on a more complicated problem: playing Tic-tac-toe. We'll concentrate on the code structure rather than on the game AI, so I have moved all Tic-tac-toe-specific functions to the end of the chapter.

#+begin_src python :noweb yes :tangle ../src/tic_tac_toe.py
  <<TIC_TAC_TOE_IMPORTS>>
  <<TIC_TAC_TOE_UTILS>>
  <<TIC_TAC_TOE_EVAL>>
  <<TIC_TAC_TOE_TREE>>
  <<TIC_TAC_TOE_PLAY>>
#+end_src

* Build a (lazy) game tree
Remember that =repeat_f= (defined [[diff.org][here]]) repeatedly maps a function to an initial value to generate a list. =repree= extends the idea to trees. Let =f= be a function that takes a value, and returns a list of values. =reptree= grows a tree out of an initial value by applying =f= repeatedly:
#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def reptree(f: Callable, label) -> Tuple:
      """Appy a function f to a label repeatedly to create a tree.
      f(label) is a list of labels
      """
      def make_children(lst):
          if lst == None:
              # f produces nothing
              return None
          else:
              # else, apply f repeatedly to elements of lst
              return map(lambda b: reptree(f, b), lst)

      return (label, make_children(f(label)))
#+end_src

By applying =moves= repeatedly to a board configuration, we get a tree of all possible future configurations of the game! =reptree= is lazy, so this large tree has not been created yet at this point. The future configurations will only be computed when they are needed.
#+begin_src python :noweb yes :tangle ../src/game.py
  <<GAME_IMPORTS>>

  def gametree(moves: Callable[[List], Union[Iterator, None]]) -> Callable[[List], Tuple]:
      """Return a func that builds a gametree from an initial board.
      moves is a function that returns all legal moves given a board.
      """
      def gametree_(board):
          return reptree(moves, board)
      return gametree_
#+end_src

The code above defines =gametree= as "factory function", which receives a =moves= function and returns a closure that only needs the board as its input. It's done this way to make calling =gametree= easier. In Appendix 3, I used the factory function above to define a version of =gametree= specifically for Tic-tac-toe. We'll use the Tic-tac-toe version for the rest of this chapter.

Here, we generate all possible Tic-tac-toe games! Let's find out how big the tree is.
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  <<TEST_TIC_TAC_TOE_IMPORTS>>

  def test_gametree():
      print("\n\n## test_gametree: no pruning")
      b0 = init_board()
      t = gametree(b0)
      d = tree_depth(t)
      print("depth=", d)

  def test_gametree2():
      b0 = init_board()
      t = gametree(b0)
      s = tree_size(t)
      print("size=", s)
#+end_src

* Prune the game tree
We can reduce the size of game tree by removing nodes after a certain depth (=n=). 
#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def prune(n: int, tree: Tuple):
      """Remove nodes n levels below in the tree"""
      (board, subtrees) = tree

      if n == 0:
          return (board, None)
      elif subtrees is None:
          return (board, None)
      else:
          return (board, map(lambda t: prune(n - 1, t), subtrees))
#+end_src

As in the previous section, I defined a Tic-tac-toe version of =prune= in Appendix 3. This version of =prune= doesn't need the depth in the input, because it uses a pre-defined value. 

Let's check the size of the pruned tree:
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_prune():
      print("\n\n## test_prune: after pruning")
      b0 = init_board()
      t = prune(gametree(b0))
      d = tree_depth(t)
      print("depth=", d)
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_prune2():
      b0 = init_board()
      t = prune(gametree(b0))
      s = tree_size(t)
      print("size=", s)
#+end_src

* Apply static evaluation to the game tree
To play Tic-tac-toe, we need a static evaluation function to guide the selection of the next move. This function does not take future moves into account, so it's not good enough for making the next move, but it's a starting point.

In Appendix 2, I defined =static_eval(player)= for this purpose. For a given =player=, the function evaluates if the configuration looks good. A positive number means that the configuration is good for =player=. A negative number means that it's good for the other player (see Appendix 2 to see example uses). 

* Implement the Minimax algorithm
#+begin_src python :noweb yes :tangle ../src/game.py
  def maximize1(gametree: Tuple) -> int:
      """The max step of Minimax"""
      (score, subtrees) = gametree

      if subtrees is None:
          s = score
      else:
          s = max(map(minimize1, subtrees))
      return s

  def minimize1(gametree: Tuple) -> int:
      """The min step of Minimax.
      A node in gametree is ((board, score), subtrees)
      Returns (board, score) with the minimal score
      """    
      (score, subtrees) = gametree

      if subtrees is None:
          s = score
      else:
          s = min(map(maximize1, subtrees))
      return s
#+end_src

This is our first attempt at the tree evaluation function:
#+begin_src python :noweb yes :tangle ../src/game.py
  def evaluate1(gametree_: Callable, eval_: Callable, prune_: Callable) -> Callable:
      def evaluate_(board: Tuple) -> int:
          return minimize1(maptree(eval_, prune_(gametree_(board))))
      return evaluate_
#+end_src

#+begin_src python :noweb yes :tangle ../src/game.py
  def max_assoc(itr):
      """ Return the board with the highest score.
      itr is (board1, score1), (board2, score2)...
      """
      def max_f(new_item, old_item):
          return new_item if new_item[1] > old_item[1] else old_item

      first_item = next(itr)
      return reduce(max_f, itr, first_item)[0]
    
  def max_next_move(gametree_func: Callable, tree_eval_func: Callable) -> Callable:
      """Return a function to make the next move."""
      def max_next_move_(board: List) -> Union[List, None]:
          # return a board or None
          (_, subtree) = gametree_func(board)
          subtrees_evaluated = map(lambda next_move: (next_move[0], tree_eval_func(next_move[0])), subtree)
          return max_assoc(subtrees_evaluated)
      return max_next_move_
#+end_src

As before, the function defined above is generic. I have defined a version (in Appendix 3) that is specific to Tic-tac-toe. It can be called with just a board configuration.

* Appendix 1: Tic-tac-toe utilities
These functions define the Tic-tac-toe game.
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_UTILS
  ### gameplay options
  use_player_token = True
  shuffle_moves = False
  max_depth = 5

  ### board configuration and geometry
  posinf = 100000
  neginf = -1 * posinf

  num_pos = 9
  line_idx = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]

  def init_board() -> List:
      """Creat an empty board.
      An unoccupied position is represented by None"""
      board = [None for i in range(num_pos)]
      return board

  def board_line(line_idx: List, board: List) -> List:
      """Return a line (one of line_idx) of a board"""
      return [board[i] for i in line_idx]

  def board_lines(board: List) -> List:
      """Return all the lines in a board"""
      return list(map(lambda idx: board_line(idx, board), line_idx))

  def won(board: List, player: int) -> bool:
      """Has player won?"""
      assert player in [0, 1]
      lines = board_lines(board)

      if any(map(lambda l: l.count(player) == 3, lines)):
          return True
      else:
          return False

  ### Moves
  def player_token(i: int) -> str:
      assert i in [0, 1]

      if use_player_token:
          return "X" if i == 0 else "O"
      else:
          return "0" if i== 0 else "1"

  def make_move(board: List, move: int, current_player: int) -> List:
      """Apply a move (0-8) to a board for a player.
      Return a new board.
      """
      new_board = board.copy()
      assert new_board[move] is None
      assert current_player in [0, 1]

      new_board[move] = current_player

      return new_board

  def who_plays(board: List) -> int:
      """Which player is playing the next move?"""
      return board.count(0) - board.count(1)

  def moves(board: List) -> Union[Iterator, None]:
      """Returns an iterator of boards for all legal next moves."""
      next_player = who_plays(board)
      other_player = (next_player + 1) % 2

      if won(board, other_player):
          # There is no legal move if the game is already won
          return None
      else:
          candidate_moves = [i for i in range(num_pos) if board[i] is None]

          if shuffle_moves:
              shuffle(candidate_moves)

          if len(candidate_moves) == 0:
              return None
          else:
              return map(lambda i: make_move(board, i, next_player), candidate_moves)

  def display_board(board: List, coordinates = False) -> None:
      """Display a board"""
      def row(lst):
          return reduce(lambda a, b: a + " "+ b, lst, "")

      d = {None: '.', 1: player_token(1), 0: player_token(0)}

      zz = list(map(lambda i: d[i], board))
      zz = [zz[i:i+3] for i in range(0, 9, 3)]
      zz = list(map(row, zz))

      if coordinates:
          def d(i):
              if board[i] is None:
                  return str(i)
              else:
                  return "."
          zz2 = [d(i) for i in range(9)]
          zz2 = [zz2[i:i+3] for i in range(0, 9, 3)]
          zz2 = list(map(row, zz2))

      res = ""
      if coordinates:
          for i in range(3):
              res = res + zz[i] + "\t\t" + zz2[i] + "\n"
      else:
          for i in range(3):
              res = res + zz[i] + "\n"

      print(res[:-1])
#+end_src

Note that the player who plays the next move is encoded in the board. This information is not stored as a game state.
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_who_plays():
      b = init_board()
      assert who_plays(b) == 0

      b[1] = 0
      assert who_plays(b) == 1

      b[2] = 1
      assert who_plays(b) == 0
#+end_src

=moves= is very important because it defines all the legal moves. Some basic testing is needed:
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_moves():
      # there should be no legal move for 0 because 1 has already won
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      assert moves(b) is None

      # there should be no legal move for 0 because 0 has already won    
      b = [1, 0, 0, 1, 0, None, None, 0, 1]
      assert moves(b) is None

      # the board is full
      b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
      assert moves(b) is None
#+end_src

* Appendix 2: Static evaluation function for Tic-tac-toe
A static evaluation function takes a board configuration and returns a number representing how good the position is (without taking future moves into account). There are different ways to evaluate how good a configuration is. I implemented a very common one.

#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_EVAL
  ### Heuristic evaluation of board configurations
  def is_good_line(n: int, player: int, line: List) -> bool:
      """A typical way to evaluate if a line is good"""

      assert n in [1, 2]
      assert player in [0, 1]

      v1 = line.count(player) == n
      v2 = line.count(None) == 3 - n
      return v1 and v2

  def count_good_lines(n: int , player: int, lines: List) -> int:
      """How many good lines?"""

      assert n in [1, 2]
      assert player in [0, 1]

      zz = list(map(lambda l: is_good_line(n, player, l), lines))
      return zz.count(True)

  def static_eval_0(board: List) -> int:
      """Static board value for player 0
      >0: player 0 is doing better
      <0: player 1 is doing better
      """
      lines = board_lines(board)

      if any(map(lambda l: l.count(0) == 3, lines)):
          val = posinf
      elif any(map(lambda l: l.count(1) ==3, lines)):
          val = neginf
      else:
          x2 = count_good_lines(2, 0, lines)
          x1 = count_good_lines(1, 0, lines)

          o2 = count_good_lines(2, 1, lines)
          o1 = count_good_lines(1, 1, lines)

          val = 3 * x2 + x1 - (3 * o2 + o1)
      return val

  def static_eval(i: int) -> Callable[[List], int]:
      """Static board value for player i"""
      assert i in [0, 1], i
    
      def static_eval_(board):
          v = static_eval_0(board)
          if i == 0:
              return v
          else:
              return -1 * v
        
      return static_eval_
#+end_src

Using the =maptree= function defined in a [[lazy_tree.org][previous chapter]], we can score an entire game! The following shows the distribution of the scores in a pruned tree:
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_static_eval():
      """Apply static eval to a game tree"""
      print("\n## test_static_eval2")
      def freq(lst):
          dict = {}
          for i in lst:
              if i in dict:
                  dict[i] = dict[i] + 1
              else:
                  dict[i] = 1
          return dict

      def show_freq(dict):
          k = dict.keys()
          k = sorted(k)
          for kk in k:
              print(f'{kk:10}     {dict[kk]}')

      b0 = init_board()
      t = prune(gametree(b0))
      t = maptree(static_eval(0), t)
      t = list(tree_labels(t))
      show_freq(freq(t))
#+end_src

It's important that the static evaluation function knows when a player wins the game.
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_static_eval_winning_condition():
      # evaluate for player 0
      eval_0 = static_eval(0)
      # evaluate for player 1
      eval_1 = static_eval(1)

      # player 0 won
      b = [1, 0, 0, 1, 0, None, None, 0, 1]
      assert eval_0(b) == posinf
      assert eval_1(b) == neginf

      # player 1 won
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      assert eval_0(b) == neginf
      assert eval_1(b) == posinf
#+end_src

* Appendix 3: Tic-tac-toe gametree
Functions related to game theory (=gametree=, =prune=, =evaluate=) defined in =game.py= are generic, and therefore require a couple of parameters to call. Here, we define Tic-tac-toe specific versions of these functions, to make them easier to use.

#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_TREE
  # gametree takes a board configuration and returns a tree
  gametree = game.gametree(moves)

  # prune takes a tree and returns another tree
  def prune(tree):
      return lazy_utils.prune(max_depth, tree)

  # given a player, returns a tree evlauation function that takes a board configuration and returns a number
  def evaluate1(player: int):
      """Evaluate tic-tac-toe tree for player i (version 1)"""
      return game.evaluate1(gametree, static_eval(player), prune)

  # given a tree evaluation function, return a function that takes a board and returns a board
  def max_next_move(tree_eval_func):
      return game.max_next_move(gametree, tree_eval_func)
#+end_src

The winning conditions have to be reflected in the game tree. Let's make sure that they are:
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_game_tree_structure():
      # Since player 0 has won, there should be no subtrees
      b = [1, 0, 0, 1, 0, None, None, 0, 1]
      t = gametree(b)
      assert t[1] is None

      # Since player 1 has won, there should be no subtrees
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      t = gametree(b)
      assert t[1] is None

      # This is a draw. There should be no subtrees
      b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
      t = gametree(b)
      assert t[1] is None
#+end_src

The static evaluation function, when applied to the game tree, should also reflect the winning conditions.
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_gametree_evaluation():
      # player 0 has won
      b = [1, 0, 0, 1, 0, None, None, 0, 1]
      (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
      assert subtrees is None and score == posinf

      # player 1 has won
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
      assert subtrees is None and score == neginf

      # This is a draw
      b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
      (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
      assert subtrees is None and score == 0
#+end_src

* Appendix 4: Testing the tree evaluation function
#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  def test_tree_eval():
      b = [1, 0, 0, None, 0, None, 1, None, None]
      print("\nGiven this board, player 1 to play")
      player = 1
      display_board(b)

      print("\nThis move wins")
      b = [1, 0, 0, 1, 0, None, 1, None, None]
      display_board(b)
      score = evaluate1(player)(b)
      assert score == posinf

      print("\nThis move will lose in the next move, so should get a losing score")
      b = [1, 0, 0, None, 0, 1, 1, None, None]
      display_board(b)
      score = evaluate1(player)(b)
      assert score == neginf

      print("\nThis move will win in the next move, so should get a winning score")
      b = [1, 0, 0, None, 0, None, 1, 1, None]
      display_board(b)
      score = evaluate1(player)(b)
      assert score == posinf
#+end_src

* Appendix 5: Gameplay
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_PLAY
  def human_next_move(board: List) -> Union[List, None]:
      """Display current board, ask player to make the next move.
      Return a board after the player's move.
      """
      display_board(board, coordinates = True)
      legal_moves = [i for i in range(num_pos) if board[i] is None]
      if legal_moves == []:
          return None
      else:
          player = who_plays(board)

          ok = False
          while not ok:
              m = input(f"player {player_token(player)} move?")
              try:
                  i = int(m)
                  if i in legal_moves:
                      ok = True
              except ValueError:
                  pass

          return make_move(board, i, player) 
#+end_src

#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_PLAY
  def computer_next_move(board: List) -> Union[List, None]:
      player = who_plays(board)
      computer_move_function = max_next_move(evaluate1(player))
      return computer_move_function(board)
#+end_src

#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_PLAY
  def player_next_move(board, player_settings = {0: 'human', 1: 'computer'}):
      player = who_plays(board)
      if player_settings[player] == 'human':
          return human_next_move(board)
      else:
          return computer_next_move(board)
#+end_src

#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_PLAY
  def play(player_settings = {0: 'human', 1: 'computer'}):
      b = init_board()

      finished = False
      while not finished:
          b = player_next_move(b, player_settings)
          player = (who_plays(b) + 1) % 2
          print()
          print(f"{player_token(player)} played:")
          display_board(b)
          print()

          assert b is not None
          if won(b, player):
              print(f"{player_token(player)} won!")
              finished = True
          elif len([i for i in range(num_pos) if b[i] is None]) == 0:
              print("Draw!")
              finished = True  
#+end_src

* Appendix 6: Imports
#+begin_src python :tangle no :noweb-ref TIC_TAC_TOE_IMPORTS
  from typing import List, Iterator, Union, Callable
  from functools import reduce
  from random import shuffle

  from lazy_utils import maptree
  import lazy_utils
  import game
#+end_src

#+begin_src python :tangle no :noweb-ref GAME_IMPORTS
  from functools import reduce
  from typing import Callable, List, Union, Iterator, Tuple
  from lazy_utils import reptree, maptree, prune
#+end_src

#+begin_src python :noweb yes :noweb-ref TEST_TIC_TAC_TOE_IMPORTS
  from tic_tac_toe import init_board, moves, static_eval_0, static_eval, display_board, who_plays, posinf, neginf, gametree, prune, evaluate1
  from lazy_utils import tree_size, tree_depth, maptree, tree_labels
#+end_src
