#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+EXPORT_FILE_NAME: ../html/tic-tac-toe.html
#+TITLE: Tic-Tac-Toe

In this section, we're going to apply the ideas developed so far on a more complicated problem: playing a simple two-person game. We'll see an elegant implementation of the minimax algorithm in the style of lazy evaluation.

* Some Tic-Tac-Toe utilities
#+begin_src python :noweb yes :tangle ../src/tic_tac_toe.py
  from typing import Tuple, List, Union, Iterator
  from functools import reduce

  num_pos = 9

  def mk_state(board, player, move):
      return (board, player, move)

  def decompose_state(state):
      board = state[0]
      last_player = state[1]
      last_move = state[2]
      return (board, last_player, last_move)

  def init_state():
      board = [None for i in range(num_pos)]
      last_player = None
      last_move = None
      return mk_state(board, last_player, last_move)

  def make_move(board, move: int, current_player: int) -> List:
      new_board = board.copy()
      assert new_board[move] == None

      new_board[move] = current_player

      return mk_state(new_board, current_player, move)

  def moves(state) -> Iterator:
      """Returns an iterator of game states of all legal next moves"""
      (board, last_player, last_move) = decompose_state(state)
      if last_player is None:
          next_player = 0
      else:
          next_player = (last_player + 1) % 2

      candidate_moves = [i for i in range(num_pos) if board[i] is None]
      return map(lambda i: make_move(board, i, next_player), candidate_moves)

  def display_board(board):
      def row(lst):
          return reduce(lambda a, b: a + b, lst, "")

      d = {None: '.', 1: 'O', 0: 'X'}
      zz = list(map(lambda i: d[i], board))
      zz = [zz[i:i+3] for i in range(0, 9, 3)]
      zz = map(row, zz)
      zz = reduce(lambda a, b: a + "\n" + b, zz, "")
      print(zz)    
#+end_src

* Build a (lazy) game tree
#+begin_src python :noweb yes :tangle ../src/game.py
  def reptree(f, label):
      """Appy a function f to all labels in a tree repeatedly."""
      return (label, map(lambda b: reptree(f, b), f(label)))

  def gametree(moves, state):
      """Build a game tree given an initial state.
      moves is a function to return all leagal moves given a state.
      """
      return reptree(moves, state)
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  from tic_tac_toe import init_state, display_board, moves
  from game import gametree, prune

  b0 = init_state()
  t = gametree(moves, b0)

  def visit(t):
      (state, subtrees) = t
      display_board(state[0])
      n = next(subtrees)
      visit(n)
#+end_src

* Prune the game tree
#+begin_src python :noweb yes :tangle ../src/game.py
  def prune(n, tree):
      (state, subtrees) = tree
      if n == 0:
          return (state, iter([]))
      else:
          return (state, map(lambda t: prune(n - 1, t), subtrees))
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_tic_tac_toe.py
  t2 = prune(3, t)
  visit(t2)
#+end_src

* Static evaluation function
