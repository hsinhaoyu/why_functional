#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+EXPORT_FILE_NAME: ../html/game.html
#+OPTIONS: broken-links:t
#+TITLE: Play games using lazy trees
In this chapter, we will apply the ideas developed so far to a more complicated problem: playing a two-player game. We'll develop the game AI code here, and then we'll use them to play Tic-tac-toe in the [[org/tic_tac_toe.org][next chapter]].

* Build a (lazy) game tree
Remember that =repeat_f= (defined [[diff.org][here]]) repeatedly applies a function to an initial value to generate a list. Let's extend the idea to trees. Let =f= be a function that takes a value, and returns a list of values. We define =reptree= to grows a tree out of an initial value by applying =f= repeatedly. Recall that tree is represented by =Node= defined in the [[lazy_tree.org][previous section]]. 
#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def reptree(f: Callable[[Any], Optional[Iterator[Any]]], label: Any) -> Node:
      """Appy a function f to a label repeatedly to create a tree.
      f(label) is a list of labels
      """
      def make_children(lst):
          if lst is None:
              # f produces nothing
              return None
          else:
              # else, apply f repeatedly to elements of lst
              return map(lambda b: reptree(f, b), lst)

      return Node(label, make_children(f(label)))
#+end_src

For playing games, we represent the rules of the game in a function called =moves=. This function takes a initial state of the game board, and returns an iterator of board configurations corresponding to all legal moves (see [[org/tic_tac_toe.org][next chapter]] for a concrete example). By applying =moves= repeatedly to an initial board configuration, we get a tree of all possible future configurations of the game! Remember that =reptree= is lazy, so this large tree has not been created yet at this point. The future configurations will only be computed when they are needed.
#+begin_src python :noweb no-export :tangle ../src/game.py
  <<GAME_IMPORTS>>

  # Board is a type alias for representing a board configuration.
  # In this example,  it's just a list
  Board = List

  <<GAME_UTILS>>

  def gametree(moves: Callable[[Board], Optional[Iterator[Board]]]) -> Callable[[Board], Node]:
      """Return a func that builds a gametree from an initial board.
      moves is a function that returns all legal moves given a board.
      """
      def gametree_(board: Board) -> Node:
          return reptree(moves, board)
      return gametree_
#+end_src

The code above defines a =gametree= as "factory function", which receives =moves= and returns a closure that only needs the initial board configuration as its input. This way, it's easier to customized it for a specific game.

* Prune the game tree
To find the best next move, searching the entire game tree is typically impractical. We can reduce the size of the search space by limiting the game AI to looks ahead for only a fixed number of moves. The =prune= function does this by removing nodes after a certain depth (=n=). 
#+begin_src python :noweb yes :tangle ../src/lazy_utils.py
  def prune(n: int, tree: Node) -> Node:
      """Remove nodes n levels below in the tree"""
      (board, subtrees) = tree

      if n == 0:
          return Node(board, None)
      elif subtrees is None:
          return Node(board, None)
      else:
          return Node(board, map(lambda t: prune(n - 1, t), subtrees))
#+end_src

* Static evaluation 
To play games, we need a static evaluation function to score each board configuration with a value, in order to guide the selection of the next move. This function does not take future moves into account, so it's not good enough for making the next move. But it's a good starting point.

The [[org/tic_tac_toe.org][next chapter]] customizes the code above to play Tic-tac-toe: =init_board= creates an empty game board, =gametree= creates a game tree, =prune= prunes a tree, and =static_eval(0)= scores a board configuration with a static evaluation function for player 0. The statement below replaces the labels in the game tree with the static scores. There is another function that keeps the board configuration and the score.
#+begin_src python
  maptree(static_eval(0), prune(gametree(init_board())))
#+end_src

Recall that =maptree= was defined in a the [[org/lazy_tree.org][lazy tree chapter]].

* Minimax (using mutually recursive functions)
[[https://en.wikipedia.org/wiki/Minimax][Minimax]] is an algorithm for playing zero-sum two-player games. If a computer plays against a human opponent, Minimax selects the computer's best move in two steps: For every legal move that the computer can make, find the worst that the human can do to the computer in a follow-up move (this is the "min" step). Then take the move that is associated with the best outcome for the computer (the "max" step). But how does the computer know what's the worst that the human can do to it? It's the other side of the coin: It's the human's best move against the computer future moves. It's not hard to see that Minimax is naturally expressed as a pair of mutually recursive functions:
#+begin_src python :noweb yes :tangle ../src/game.py
  def maximize1(gametree: Node) -> int:
      """The max step of Minimax"""
      (score, subtrees) = gametree

      if subtrees is None:
          s = score
      else:
          s = max(map(minimize1, subtrees))
      return s

  def minimize1(gametree: Node) -> int:
      """The min step of Minimax.
      A node in gametree is ((board, score), subtrees)
      Returns (board, score) with the minimal score
      """    
      (score, subtrees) = gametree

      if subtrees is None:
          s = score
      else:
          s = min(map(maximize1, subtrees))
      return s
#+end_src

The code below is the first version of our tree evaluation function. The code is easy to read, because it's a chain of functions: given a board configuration, creates a game tree of all possible configurations, prune it to limit the search to a fixed steps ahead, apply the static evaluation to all the nodes, and then uses Minimax to return a score. Note that all the functions in the chain are lazy. Although the code reads like pruning, scoring, and minimaxing apply to the whole tree, only the parts that are needed will be evaluated.
#+begin_src python :noweb yes :tangle ../src/game.py
  def evaluate1(gametree_: Callable[[Board], Node], static_eval_: Callable[[Board], int], prune_: Callable[[Node], Node]) -> Callable[[Board], int]:
      """Return a tree evaluation function"""
      def evaluate_(board: Board) -> int:
          return maximize1(maptree(static_eval_, prune_(gametree_(board))))
      return evaluate_
#+end_src

* A slight modification
#+begin_src python :noweb yes :tangle filename
  def maximize2_(gametree: Node) -> int:
      """The max step of Minimax"""
      (score, subtrees) = gametree

      if subtrees is None:
          s = score
      else:
          s = map(minimize1, subtrees)
      return s

  def minimize2_(gametree: Node) -> int:
      """The min step of Minimax.
      A node in gametree is ((board, score), subtrees)
      Returns (board, score) with the minimal score
      """    
      (score, subtrees) = gametree

      if subtrees is None:
          s = score
      else:
          s = map(maximize1, subtrees)
      return s
#+end_src

* Alpha-beta pruning (using iterators of iterators)
In the previous section, the tree evaluation function uses the lazy tree is efficient: because only a segment of the tree is needed at a time, the entire tree doesn't need to be stored in memory. Once a branch has been evaluated, it can be garbage collected immediately. However, Minimax does need to visit every node in the tree. Is there a way to prevent Minimax from visiting branches that are obviously not promising?

The answer is yes. The trick is a pair of functions called =mapmin= and =mapmax=. I'll only describe what they do. The code is in the end of this chapter. =mapmin= is just like =map(min(...))=, except that it skips some unnecessary computation. How is it possible to skip any computation? Take this example: [[1, 2], [0, X]]. Following the logic of Minimax, we need the max of the min of the two sublists. The min of [1, 2] is 1. When we get to [0, X], we don't know the min, because X is unknown. However, we know that min([0, X])<=0. That means no matter what X is, min([0, X]) cannot be larger than the current max (which is 1). X therefore doesn't matter in the calculation of the max. If evaluation X is computationally demanding, this saves time.

#+begin_src python :noweb no-export :tangle ../src/game.py
  <<ALPHA_BETA_UTILS>>
#+end_src

* Alpha-beta utilities
To implement =mapmin=, we begin with =minleq=. Given an iterator =seq= and a "potential max" =mx=, =minleq(seq, mx)= returns if the iterator can be "omitted". For example, the following statement returns True.
#+begin_src python
  minleq(iter([3, 2, 5, 30, 1, 6]), 20)
#+end_src

=minleq(itr, 20)= is looking for a value greater than 20. The first value of =itr= is 3, which means that the minimum of =itr= is not big enough to replace 20 as the potential maximum. The rest of the iterator therefore does not need to be evaluated further. The returned value =True= indicates that this sequence is to be omitted. In the context of games, this is not a move that needs to be considered further, because the first counter-move we consider is already pretty bad (3), It's true that the 4th counter-move can be very good for us (30), but we can't count on the opponent making a blunder, can we?

The following statement, however, returns 1.
#+begin_src python
  minleq(iter([3, 2, 5, 30, 1, 6]), 0)
#+end_src

This sequence cannot be omitted because all numbers are larger than the potential max. In that case, the minimum (1) is return. In the context of games, this move is stronger than what had been considered before, because no matter what the counter-move is, we always end up in a better position.

Here's the code. See [[org/tests.org][test.org]] for more examples.
#+begin_src python :tangle no :noweb-ref ALPHA_BETA_UTILS
  def mk_ab_seq(comp: Callable, op: Callable) -> Callable:
      """Given a comparison function comp and an operator op, return a function."""
      def ab_seq(seq: Optional[Iterator], pot: int) -> Optional[Union[int, bool]]:
          """Efficient min/max of an iterator, given potential max/min"""
          def ab_seq_(seq, current_val):
              try:
                  i = next(seq)
                  if current_val is None:
                      current_val = i

                  if comp(i, pot):
                      # if smaller, returns true immediately
                      return True
                  else:
                      return ab_seq_(seq, op(i, current_val))
              except StopIteration:
                  if current_val is None:
                      return pot
                  else:
                      return current_val

          if seq is None:
              return pot
          else:
              return ab_seq_(seq, None)

      return ab_seq

  minleq = mk_ab_seq(operator.le, min)
  minleq.__doc__ = """
  Return min of seq if it's > potential max.
  Else return True"""

  maxgeq = mk_ab_seq(operator.ge, max)
  maxgeq.__doc__ = """
  Return max of seq if it's < potential min.
  Else return True"""
#+end_src

With =minleq=, we can write =mapmin=. It takes a iterators of sub-iterators, and return the minima of the sub-iterators, omitting the sub-iterators that don't matter. For example, the following code returns [1, 3]. Note that it is an increasing sequence.
#+begin_src python :noweb yes :tangle filename
  seqs = iter([iter([1, 2]), iter([0, 10]), iter([3, 20]), iter([1, 100])])
  list(mapmin(seqs))
#+end_src

Here's the implementation:
#+begin_src python :tangle no :noweb-ref ALPHA_BETA_UTILS
  def mapmin(seqs: Iterator[Iterator]) -> Iterator:
      """Like map(min, seqs)
      But skip those that don't matter for max.
      The sequence increases monotonically
      """
      try:
          seq = next(seqs)
          mn = min(seq)
          yield mn
          for i in omit_max(mn, seqs):
              yield i
      except StopIteration:
          pass

  def mapmax(seqs: Iterator[Iterator]) -> Iterator:
      """Like map(max, seqs)
      But skip those that don't matter for min
      The sequence decreases monotonically
      """
      try:
          seq = next(seqs)
          mx = max(seq)
          yield mx
          for i in omit_min(mx, seqs):
              yield i
      except StopIteration:
          pass

  def mk_omit(skip_func: Callable) -> Callable:
      """The skip function is either minleq or maxgeq"""
      def omit_(pot: int, seqs: Optional[Iterator[Iterator[int]]]) -> Iterator[Optional[int]]:
          """Given an iterator of iterators, call skip_func.
          If the returned value is true, skip it. Otherwise, yield the value
          """
          for seq in seqs:
              m = skip_func(seq, pot)
              if m is True:
                  for i in omit_(pot, seqs):
                      yield i
              else:
                  yield m
                  for i in omit_(m, seqs):
                      yield i

      return omit_

  omit_max = mk_omit(minleq)
  omit_max.__doc__ = """
  Given an initial potential max, return the min of subsequences.
  Skip those that don't matter. Sequence increases.
  """

  omit_min = mk_omit(maxgeq)
  omit_max.__doc__ = """
  Given an initial potental min, return the max of subsequences.
  Skip those that don't matter. Sequence decreases.
  """
#+end_src

=mapmin=, =omit_max= and =minleq= are for the max step. Similarly, =mapmax=, =omit_min= and =maxgeq= are for the min step. 

* Appendix: Imports
#+begin_src python :tangle no :noweb-ref GAME_IMPORTS
  from functools import reduce
  from typing import Callable, List, Iterator, Tuple, Optional, Union
  from lazy_utils import reptree, maptree, Node
  import operator
#+end_src

#+begin_src python :tangle no :noweb-ref RUNTIME_IMPORTS
  from typing import Callable, Optional, Iterator, Union
  import operator
#+end_src
