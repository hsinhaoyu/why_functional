<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-03-26 Sat 22:30 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Let's play Tic-tac-toe</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Hsin-Hao Yu" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Let's play Tic-tac-toe</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org7c26080">1. The Tic-tac-toe game board</a></li>
<li><a href="#org3dd2628">2. Legal moves</a></li>
<li><a href="#org8e77114">3. The Tic-tac-toe game tree</a></li>
<li><a href="#org6ffc4bb">4. Static evaluation</a></li>
<li><a href="#orgf13fac0">5. Score the game tree</a></li>
<li><a href="#org8bfafb7">6. Minimax</a></li>
<li><a href="#org9b0a284">7. Gameplay</a></li>
<li><a href="#org0125d7d">8. Imports</a></li>
</ul>
</div>
</div>
<p>
This chapter uses the game AI code developed in the to play Tic-tac-toe. To play the game, run <code>tic_tac_toe.play()</code>. This part is not in Hughes' paper.
</p>

<div class="org-src-container">
<pre class="src src-python">&lt;&lt;TIC_TAC_TOE_IMPORTS&gt;&gt;
&lt;&lt;TIC_TAC_TOE_RULES&gt;&gt;
&lt;&lt;TIC_TAC_TOE_TREE&gt;&gt;
&lt;&lt;TIC_TAC_TOE_STATIC&gt;&gt;
&lt;&lt;TIC_TAC_TOE_MINIMAX&gt;&gt;
&lt;&lt;TIC_TAC_TOE_PLAY&gt;&gt;
</pre>
</div>

<div id="outline-container-org7c26080" class="outline-2">
<h2 id="org7c26080"><span class="section-number-2">1</span> The Tic-tac-toe game board</h2>
<div class="outline-text-2" id="text-1">
<p>
These functions define the Tic-tac-toe game world:
</p>
<div class="org-src-container">
<pre class="src src-python">### gameplay options
use_player_token = True
shuffle_moves = False
max_depth = 5

posinf = 100000
neginf = -1 * posinf

num_pos = 9
line_idx = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]

# Cell is a type alias for representing the state of a cell in a board
Cell = Optional[int]
# Board is a type alias for representing board configurations
Board = List[Cell]

def init_board() -&gt; Board:
    """Creat an empty board.
    An unoccupied position is represented by None"""
    board: List[Optional[int]] = [None for i in range(num_pos)]
    return board

def board_line(line_idx: List[int], board: Board) -&gt; List[Cell]:
    """Return a line (one of line_idx) of a board"""
    return [board[i] for i in line_idx]

def board_lines(board: Board) -&gt; List[List[Cell]]:
    """Return all the lines in a board"""
    return list(map(lambda idx: board_line(idx, board), line_idx))

def won(board: Board, player: int) -&gt; bool:
    """Has player won?"""
    assert player in [0, 1]
    lines = board_lines(board)

    if any(map(lambda l: l.count(player) == 3, lines)):
	return True
    else:
	return False

def who_plays(board: Board) -&gt; int:
    """Which player is playing the next move?"""
    return board.count(0) - board.count(1)
</pre>
</div>

<p>
Note that the player who plays the next move is not stored as a game state, because it can easily be inferred from the game board by <code>who_plays</code>.
</p>
<div class="org-src-container">
<pre class="src src-python">def test_who_plays():
    b = init_board()
    assert who_plays(b) == 0

    b[1] = 0
    assert who_plays(b) == 1
</pre>
</div>
</div>
</div>

<div id="outline-container-org3dd2628" class="outline-2">
<h2 id="org3dd2628"><span class="section-number-2">2</span> Legal moves</h2>
<div class="outline-text-2" id="text-2">
<p>
The function <code>moves</code> encapsulates the legal moves of Tic-tac-toe. Given a board configuration, <code>moves</code> returns an iterator of board configurations associated with the legal next moves.
</p>
<div class="org-src-container">
<pre class="src src-python">def make_move(board: Board, move: int, current_player: int) -&gt; Board:
    """Apply a move (0-8) to a board for a player.
    Return a new board.
    """
    new_board = board.copy()
    assert new_board[move] is None
    assert current_player in [0, 1]

    new_board[move] = current_player

    return new_board

def moves(board: Board) -&gt; Optional[Iterator[Board]]:
    """Returns an iterator of boards for all legal next moves."""
    next_player = who_plays(board)
    other_player = (next_player + 1) % 2

    if won(board, other_player):
	# There is no legal move if the game is already won
	return None
    else:
	candidate_moves = [i for i in range(num_pos) if board[i] is None]

	if shuffle_moves:
	    shuffle(candidate_moves)

	if len(candidate_moves) == 0:
	    return None
	else:
	    return map(lambda i: make_move(board, i, next_player), candidate_moves)
</pre>
</div>

<p>
Simple tests to make sure that <code>moves</code> knows it when no legal moves are available.
</p>
<div class="org-src-container">
<pre class="src src-python">def test_moves():
    # there should be no legal move for 0 because 1 has already won
    b = [1, 0, 0, 1, 0, None, 1, None, None]
    assert moves(b) is None

    # there should be no legal move for 0 because 0 has already won    
    b = [1, 0, 0, 1, 0, None, None, 0, 1]
    assert moves(b) is None

    # A draw. the board is full
    b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
    assert moves(b) is None
</pre>
</div>
</div>
</div>

<div id="outline-container-org8e77114" class="outline-2">
<h2 id="org8e77114"><span class="section-number-2">3</span> The Tic-tac-toe game tree</h2>
<div class="outline-text-2" id="text-3">
<p>
In the previous chapter, we defined generic <code>gametree</code> and <code>prune</code>. Here, we customize them for Tic-tac-toe:
</p>
<div class="org-src-container">
<pre class="src src-python">gametree: Callable[[Board], Node] = game.gametree(moves)

def prune(tree: Node) -&gt; Node:
    return lazy_utils.prune(max_depth, tree)
</pre>
</div>

<p>
With these, we can generate all possible Tic-tac-toe games! Let's find out how big the tree is.
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;

d = tree_depth(gametree(init_board()))
print("depth=", d)
n = tree_size(gametree(init_board()))
print("# nodes=", n)
</pre>
</div>

<p>
For playing Tic-tac-toe, we set a limit to the depth of the game tree to <code>max_depth</code>, which is set to 5. Let's check the size of the pruned tree:
</p>
<div class="org-src-container">
<pre class="src src-python">def test_prune():
    print("\n\n## test_prune: after pruning")
    b0 = init_board()
    t = prune(gametree(b0))
    d = tree_depth(t)
    print("depth=", d)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def test_prune2():
    b0 = init_board()
    t = prune(gametree(b0))
    s = tree_size(t)
    print("size=", s)
</pre>
</div>

<p>
The winning conditions have to be reflected in the game tree. Let's make sure that they are:
</p>
<div class="org-src-container">
<pre class="src src-python">def test_game_tree_structure():
    # Since player 0 has won, there should be no subtrees
    b = [1, 0, 0, 1, 0, None, None, 0, 1]
    assert won(b, 0) == True
    t = gametree(b)
    assert t[1] is None

    # Since player 1 has won, there should be no subtrees
    b = [1, 0, 0, 1, 0, None, 1, None, None]
    assert won(b, 1) == True
    t = gametree(b)
    assert t[1] is None

    # This is a draw. There should be no subtrees
    b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
    assert won(b, 0) == False
    assert won(b, 1) == False
    t = gametree(b)
    assert t[1] is None
</pre>
</div>
</div>
</div>

<div id="outline-container-org6ffc4bb" class="outline-2">
<h2 id="org6ffc4bb"><span class="section-number-2">4</span> Static evaluation</h2>
<div class="outline-text-2" id="text-4">
<p>
A static evaluation function takes a board configuration and returns a number representing how good the position is (without taking future moves into account). There are different ways to evaluate how good a Tic-tac-toe configuration is. I implemented a common one in  <code>static_eval(player)</code>. For a given <code>player</code>, the function evaluates if the configuration "looks good". A positive number means that the configuration is good for <code>player</code>. A negative number means that it's good for the other player.
</p>
<div class="org-src-container">
<pre class="src src-python">### Heuristic evaluation of board configurations
def is_good_line(n: int, player: int, line: List[Cell]) -&gt; bool:
    """A typical way to evaluate if a line is good"""

    assert n in [1, 2]
    assert player in [0, 1]

    v1 = line.count(player) == n
    v2 = line.count(None) == 3 - n
    return v1 and v2

def count_good_lines(n: int , player: int, lines: List[List[Cell]]) -&gt; int:
    """How many good lines?"""

    assert n in [1, 2]
    assert player in [0, 1]

    zz = list(map(lambda l: is_good_line(n, player, l), lines))
    return zz.count(True)

def static_eval_0(board: Board) -&gt; int:
    """Static board value for player 0
    &gt;0: player 0 is doing better
    &lt;0: player 1 is doing better
    """
    lines = board_lines(board)

    if any(map(lambda l: l.count(0) == 3, lines)):
	val = posinf
    elif any(map(lambda l: l.count(1) ==3, lines)):
	val = neginf
    else:
	x2 = count_good_lines(2, 0, lines)
	x1 = count_good_lines(1, 0, lines)

	o2 = count_good_lines(2, 1, lines)
	o1 = count_good_lines(1, 1, lines)

	val = 3 * x2 + x1 - (3 * o2 + o1)
    return val

def static_eval(i: int) -&gt; Callable[[Board], int]:
    """Static board value for player i"""
    assert i in [0, 1]

    def static_eval_(board):
	v = static_eval_0(board)
	if i == 0:
	    return v
	else:
	    return -1 * v

    return static_eval_
</pre>
</div>

<p>
It's important that the static evaluation function knows when a player wins the game:
</p>
<div class="org-src-container">
<pre class="src src-python">def test_static_eval_winning_condition():
    # evaluate for player 0
    eval_0 = static_eval(0)
    # evaluate for player 1
    eval_1 = static_eval(1)

    # player 0 won
    b = [1, 0, 0, 1, 0, None, None, 0, 1]
    assert eval_0(b) == posinf
    assert eval_1(b) == neginf

    # player 1 won
    b = [1, 0, 0, 1, 0, None, 1, None, None]
    assert eval_0(b) == neginf
    assert eval_1(b) == posinf
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf13fac0" class="outline-2">
<h2 id="orgf13fac0"><span class="section-number-2">5</span> Score the game tree</h2>
<div class="outline-text-2" id="text-5">
<p>
Using the <code>maptree</code> function defined in a to apply the static evaluation function to every node in the game tree, we can score an entire game!
</p>

<p>
Instead of replacing each label in the game tree with a score, I want to keep the board configuration as well. So let's define a new version of <code>static_eval</code> that returns a state object. The <code>State</code> class defined below implements methods for numerical comparisons, so the Minimax-related functions defined in the previous chapter can treat a State as if it were an integer.
</p>
<div class="org-src-container">
<pre class="src src-python">@dataclass
class State:
    board: Board
    score: int

    def __eq__(self, other):
	return self.score == other.score
    def __gt__(self, other):
	return self.score &gt; other.score
    def __ge__(self, othre):
	return self.score &gt;= other.score
    def __lt__(self, other):
	return self.score &lt; other.score
    def __le__(self, other):
	return self.score &lt;= other.score
</pre>
</div>

<p>
This is the static evaluation function that returns a State:
</p>
<div class="org-src-container">
<pre class="src src-python">def static_eval_state(i: int) -&gt; Callable[[Board], State]:
    """Static board state for player i"""
    assert i in [0, 1]
    score_func = static_eval(i)

    def static_eval_(board):
	return State(board, score_func(board))

    return static_eval_
</pre>
</div>

<p>
The following shows the distribution of the scores in a pruned tree:
</p>
<div class="org-src-container">
<pre class="src src-python">def test_static_eval():
    """Apply static eval to a game tree"""
    print("\n## test_static_eval2")
    def freq(lst):
	dict = {}
	for i in lst:
	    if i in dict:
		dict[i] = dict[i] + 1
	    else:
		dict[i] = 1
	return dict

    def show_freq(dict):
	k = dict.keys()
	k = sorted(k)
	for kk in k:
	    print(f'{kk:10}     {dict[kk]}')

    b0 = init_board()
    t = prune(gametree(b0))
    t = maptree(static_eval_state(0), t)
    t = tree_labels(t) # collect all the states from the tree
    t = list(map(lambda s: s.score, t)) # extract just the scores 
    show_freq(freq(t))
</pre>
</div>

<p>
The static evaluation function, when applied to the game tree, should reflect winning conditions.
</p>
<div class="org-src-container">
<pre class="src src-python">def test_gametree_evaluation():
    # player 0 has won
    b = [1, 0, 0, 1, 0, None, None, 0, 1]
    (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
    assert subtrees is None and score == posinf

    # player 1 has won
    b = [1, 0, 0, 1, 0, None, 1, None, None]
    (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
    assert subtrees is None and score == neginf

    # This is a draw
    b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
    (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
    assert subtrees is None and score == 0
</pre>
</div>
</div>
</div>

<div id="outline-container-org8bfafb7" class="outline-2">
<h2 id="org8bfafb7"><span class="section-number-2">6</span> Minimax</h2>
<div class="outline-text-2" id="text-6">
<p>
Here's the first move evaluation function, based on just Minimax:
</p>
<div class="org-src-container">
<pre class="src src-python"># given a player, returns a tree evlauation function
def evaluate1(player: int) -&gt; Callable[[Board], State]:
    """Evaluate tic-tac-toe tree for player i (version 1)"""
    return game.evaluate1(gametree, static_eval_state(player), prune)
</pre>
</div>

<p>
Let's try it on the most basic conditions:
</p>
<div class="org-src-container">
<pre class="src src-python">def test_tree_eval():
    print("## test_tree_eval()")
    b = [1, 0, 0, None, 0, None, 1, None, None]
    print("\nGiven this board, player 1 (O) to play")
    player = 1
    display_board(b)

    best_move = evaluate1(player)(b)
    print()
    print("O's best move:")
    display_board(best_move.board)

    # player 1 should be able to win the game in one move
    # so the score should be the winning score
    assert best_move.score == posinf

#@pytest.mark.skip(reason="skip skip skip")    
</pre>
</div>
</div>
</div>

<div id="outline-container-org9b0a284" class="outline-2">
<h2 id="org9b0a284"><span class="section-number-2">7</span> Gameplay</h2>
<div class="outline-text-2" id="text-7">
<p>
Simple utilities for displaying the game board and for handling human player moves:
</p>
<div class="org-src-container">
<pre class="src src-python">def player_token(i: int) -&gt; str:
    assert i in [0, 1]
    if use_player_token:
	return "X" if i == 0 else "O"
    else:
	return "0" if i== 0 else "1"

def display_board(board: Board, coordinates = False) -&gt; None:
    """Display a board"""
    def row(lst):
	return reduce(lambda a, b: a + " "+ b, lst, "")

    d = {None: '.', 1: player_token(1), 0: player_token(0)}

    zz = list(map(lambda i: d[i], board))
    zz = [zz[i:i+3] for i in range(0, 9, 3)]
    zz = list(map(row, zz))

    if coordinates:
	def d_(i):
	    if board[i] is None:
		return str(i)
	    else:
		return "."
	zz2 = [d_(i) for i in range(9)]
	zz2 = [zz2[i:i+3] for i in range(0, 9, 3)]
	zz2 = list(map(row, zz2))

    res = ""
    if coordinates:
	for i in range(3):
	    res = res + zz[i] + "\t\t" + zz2[i] + "\n"
    else:
	for i in range(3):
	    res = res + zz[i] + "\n"

    print(res[:-1])

def human_next_move(board: Board) -&gt; Optional[Board]:
    """Display current board, ask player to make the next move.
    Return a board after the player's move.
    """
    display_board(board, coordinates = True)
    legal_moves = [i for i in range(num_pos) if board[i] is None]
    if legal_moves == []:
	return None
    else:
	player = who_plays(board)

	ok = False
	while not ok:
	    m = input(f"player {player_token(player)} move?")
	    try:
		i = int(m)
		if i in legal_moves:
		    ok = True
	    except ValueError:
		pass

	return make_move(board, i, player) 
</pre>
</div>

<p>
This let a player make a move. A player can be human or computer.
</p>
<div class="org-src-container">
<pre class="src src-python">def computer_next_move(board: Board, eval_func: Callable[[int],Callable[[Board], State]]) -&gt; Optional[Board]:
    player = who_plays(board)
    computer_move_function = eval_func(player)
    # computer_move_function is a State
    return computer_move_function(board).board

def player_next_move(board: Board, player_settings = {0: 'human', 1: 'computer'}, eval_func = evaluate1) -&gt; Optional[Board]:
    player = who_plays(board)
    if player_settings[player] == 'human':
	return human_next_move(board)
    else:
	return computer_next_move(board, eval_func)
</pre>
</div>

<p>
The main game loop:
</p>
<div class="org-src-container">
<pre class="src src-python">def play(player_settings = {0: 'human', 1: 'computer'}, eval_func = evaluate1) -&gt; None:
    b = init_board()

    finished = False
    while not finished:
	b = player_next_move(b, player_settings, eval_func)
	player = (who_plays(b) + 1) % 2
	print()
	print(f"{player_token(player)} played:")
	display_board(b)
	print()

	assert b is not None
	if won(b, player):
	    print(f"{player_token(player)} won!")
	    finished = True
	elif len([i for i in range(num_pos) if b[i] is None]) == 0:
	    print("Draw!")
	    finished = True  
</pre>
</div>
</div>
</div>
<div id="outline-container-org0125d7d" class="outline-2">
<h2 id="org0125d7d"><span class="section-number-2">8</span> Imports</h2>
<div class="outline-text-2" id="text-8">
<div class="org-src-container">
<pre class="src src-python">from typing import List, Iterator, Callable, Optional
from functools import reduce
from random import shuffle
from dataclasses import dataclass 

from lazy_utils import Node
import lazy_utils
import game
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">from tic_tac_toe import init_board, moves, static_eval, display_board
from tic_tac_toe import who_plays, posinf, neginf, gametree, prune, evaluate1, won
from tic_tac_toe import static_eval_state
from lazy_utils import tree_size, tree_depth, maptree, tree_labels
import pytest
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">from tic_tac_toe import init_board, gametree, prune
from lazy_utils import tree_size, tree_depth
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hsin-Hao Yu</p>
<p class="date">Created: 2022-03-26 Sat 22:30</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
