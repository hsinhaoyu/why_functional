<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-03-25 Fri 08:35 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Play Tic-tac-toe using lazy trees</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Hsin-Hao Yu" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Play Tic-tac-toe using lazy trees</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgbda8de4">1. Build a (lazy) game tree</a></li>
<li><a href="#orgd977e57">2. Prune the game tree</a></li>
<li><a href="#org3814c63">3. Static evaluation (using <code>maptree</code>)</a></li>
<li><a href="#org464d402">4. Minimax (using mutually recursive functions)</a></li>
<li><a href="#org3004678">5. Alpha-beta pruning (using iterators of iterators)</a></li>
<li><a href="#org9d33fe1">6. Appendix 1: Tic-tac-toe utilities</a></li>
<li><a href="#orgdf2dded">7. Appendix 2: Static evaluation function for Tic-tac-toe</a></li>
<li><a href="#org20be616">8. Appendix 3: The Tic-tac-toe gametree</a></li>
<li><a href="#orgcb55e10">9. Appendix 4: Testing the tree evaluation function</a></li>
<li><a href="#org0614245">10. Appendix 5: Gameplay</a></li>
<li><a href="#orgd401942">11. Appendix 6: Misc</a></li>
<li><a href="#org22243b0">12. Appendix 7: Imports</a></li>
</ul>
</div>
</div>
<p>
In this chapter, we're going to apply the ideas developed so far to a more complicated problem: playing Tic-tac-toe. We'll concentrate on the code structure rather than on the game AI, so I have moved all Tic-tac-toe-specific functions to the end of the chapter.
</p>

<div id="outline-container-orgbda8de4" class="outline-2">
<h2 id="orgbda8de4"><span class="section-number-2">1</span> Build a (lazy) game tree</h2>
<div class="outline-text-2" id="text-1">
<p>
Remember that <code>repeat_f</code> (defined ) repeatedly applies a function to an initial value to generate a list. Let's extend the idea to trees. Let <code>f</code> be a function that takes a value, and returns a list of values. We define <code>reptree</code> to grows a tree out of an initial value by applying <code>f</code> repeatedly. Recall that tree is represented by <code>Node</code> defined in the . 
</p>
<div class="org-src-container">
<pre class="src src-python">def reptree(f: Callable[[Any], Optional[Iterator[Any]]], label: Any) -&gt; Node:
    """Appy a function f to a label repeatedly to create a tree.
    f(label) is a list of labels
    """
    def make_children(lst):
	if lst is None:
	    # f produces nothing
	    return None
	else:
	    # else, apply f repeatedly to elements of lst
	    return map(lambda b: reptree(f, b), lst)

    return Node(label, make_children(f(label)))
</pre>
</div>

<p>
For playing game, <code>moves</code> is a function that takes a game configuration, and returns an iterator of board configurations corresponding to all legal moves. By applying <code>moves</code> repeatedly to an initial board configuration, we get a tree of all possible future configurations of the game! <code>reptree</code> is lazy, so this large tree has not been created yet at this point. The future configurations will only be computed when they are needed.
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;GAME_IMPORTS&gt;&gt;

# Board is a type alias for representing a board configuration.
# In this example,  it's just a list
Board = List

&lt;&lt;GAME_UTILS&gt;&gt;

def gametree(moves: Callable[[Board], Optional[Iterator[Board]]]) -&gt; Callable[[Board], Node]:
    """Return a func that builds a gametree from an initial board.
    moves is a function that returns all legal moves given a board.
    """
    def gametree_(board: Board) -&gt; Node:
	return reptree(moves, board)
    return gametree_
</pre>
</div>

<p>
The code above defines a <code>gametree</code> as "factory function", which receives <code>moves</code> and returns a closure that only needs the initial board configuration as its input. In Appendix 3, I used the factory function to define a version of <code>gametree</code> specifically for Tic-tac-toe. We'll use the Tic-tac-toe version of <code>gametree</code> for the rest of this chapter.
</p>

<p>
Here, we generate all possible Tic-tac-toe games! Let's find out how big the tree is.
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;TEST_TIC_TAC_TOE_IMPORTS&gt;&gt;

def test_gametree():
    print("\n\n## test_gametree: no pruning")
    b0 = init_board()
    t = gametree(b0)
    d = tree_depth(t)
    print("depth=", d)

def test_gametree2():
    b0 = init_board()
    t = gametree(b0)
    s = tree_size(t)
    print("size=", s)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd977e57" class="outline-2">
<h2 id="orgd977e57"><span class="section-number-2">2</span> Prune the game tree</h2>
<div class="outline-text-2" id="text-2">
<p>
To find the best next move, searching the entire game tree is typically impractical. We can reduce the size of the search space by limiting the game AI to looks ahead for only a fixed number of moves. The <code>prune</code> function does this by removing nodes after a certain depth (<code>n</code>). 
</p>
<div class="org-src-container">
<pre class="src src-python">def prune(n: int, tree: Node) -&gt; Node:
    """Remove nodes n levels below in the tree"""
    (board, subtrees) = tree

    if n == 0:
	return Node(board, None)
    elif subtrees is None:
	return Node(board, None)
    else:
	return Node(board, map(lambda t: prune(n - 1, t), subtrees))
</pre>
</div>

<p>
As in the previous section, I defined a Tic-tac-toe version of <code>prune</code> in Appendix 3. This version of <code>prune</code> doesn't need the depth in the input, because it uses a pre-defined value for Tic-tac-toe (which is 5).
</p>

<p>
Let's check the size of the pruned tree:
</p>
<div class="org-src-container">
<pre class="src src-python">def test_prune():
    print("\n\n## test_prune: after pruning")
    b0 = init_board()
    t = prune(gametree(b0))
    d = tree_depth(t)
    print("depth=", d)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def test_prune2():
    b0 = init_board()
    t = prune(gametree(b0))
    s = tree_size(t)
    print("size=", s)
</pre>
</div>
</div>
</div>

<div id="outline-container-org3814c63" class="outline-2">
<h2 id="org3814c63"><span class="section-number-2">3</span> Static evaluation (using <code>maptree</code>)</h2>
<div class="outline-text-2" id="text-3">
<p>
To play Tic-tac-toe, we need a static evaluation function to guide the selection of the next move. This function does not take future moves into account, so it's not good enough for making the next move. But it's a starting point.
</p>

<p>
In Appendix 2, I defined <code>static_eval(player)</code> for this purpose. For a given <code>player</code>, the function evaluates if the configuration "looks good". A positive number means that the configuration is good for <code>player</code>. A negative number means that it's good for the other player (see Appendix 2 to see example uses). 
</p>
</div>
</div>

<div id="outline-container-org464d402" class="outline-2">
<h2 id="org464d402"><span class="section-number-2">4</span> Minimax (using mutually recursive functions)</h2>
<div class="outline-text-2" id="text-4">
<p>
<a href="https://en.wikipedia.org/wiki/Minimax">Minimax</a> is an algorithm for playing zero-sum two-player games. To find the best move, Minimax looks into future states of the game in the game tree, in two alternate steps: My next move should make the best (the maximization step) out of the worst that my opponent can do to me in a future step (the minimization step). For example, if my opponent could win the game in the next move, I assume that he wouldn't miss that move, and I'll do my best to prevent him from making that move. But how do I know the worst that my opponent can do to me? It's the other side of the coin: the best out of the worst that I could do to him in a future step. It's not hard to see that Minimax is naturally expressed as a pair of mutually recursive functions:
</p>
<div class="org-src-container">
<pre class="src src-python">def maximize1(gametree: Node) -&gt; int:
    """The max step of Minimax"""
    (score, subtrees) = gametree

    if subtrees is None:
	s = score
    else:
	s = max(map(minimize1, subtrees))
    return s

def minimize1(gametree: Node) -&gt; int:
    """The min step of Minimax.
    A node in gametree is ((board, score), subtrees)
    Returns (board, score) with the minimal score
    """    
    (score, subtrees) = gametree

    if subtrees is None:
	s = score
    else:
	s = min(map(maximize1, subtrees))
    return s
</pre>
</div>

<p>
The code below is the first version of our tree evaluation function. For every legal move that I can make, I pass the board configuration to <code>evaluate1</code>, and it returns a score representing how bad my opponent can do to me in the future. A positive score means that my move is a winning move; a negative score means that my move is a losing one. The code is surprisingly easy to read, because it's a chain of functions: given a board configuration, it creates a game tree of all possible configurations, prunes it to limit the search to a fixed steps ahead, applies the static evaluation to all the nodes, and then uses Minimax to return a score.
</p>

<p>
Note that all the functions in the chain are lazy. Although the code reads like pruning, scoring, and minimaxing apply to the whole tree, only the parts that are needed will be evaluated.
</p>
<div class="org-src-container">
<pre class="src src-python">def evaluate1(gametree_: Callable[[Board], Node], static_eval_: Callable[[Board], int], prune_: Callable[[Node], Node]) -&gt; Callable[[Board], int]:
    """Return a tree evaluation function"""
    def evaluate_(board: Board) -&gt; int:
	return minimize1(maptree(static_eval_, prune_(gametree_(board))))
    return evaluate_
</pre>
</div>

<p>
Again, this version of <code>evaluate1</code> is not specific to any game, so it needs many parameters. In the Appendix 3, I defined a version of <code>evaluate1</code> that only takes the board configuration as input.
</p>

<p>
We apply <code>evaluate1</code> to all candidate moves, and pick the one with the highest score. Note that <code>max_assoc</code> is an utility function defined near the end of the document. It returns the board associated with the highest score.
</p>
<div class="org-src-container">
<pre class="src src-python">def max_next_move(gametree_func: Callable[[Board], Node], tree_eval_func: Callable[[Board], int]) -&gt; Callable[[Board], Optional[Board]]:
    """Return a function to make the next move."""
    def max_next_move_(board: Board) -&gt; Optional[Board]:
	# return a board or None
	(_, subtree) = gametree_func(board)
	if subtree is None:
	    return None
	else:
	    subtrees_evaluated = map(lambda next_move: (next_move[0], tree_eval_func(next_move[0])), subtree)
	    return max_assoc(subtrees_evaluated)
    return max_next_move_
</pre>
</div>

<p>
As before, the function defined above is generic. I have defined a version (in Appendix 3) that is specific to Tic-tac-toe. It can be called with just a board configuration.
</p>
</div>
</div>

<div id="outline-container-org3004678" class="outline-2">
<h2 id="org3004678"><span class="section-number-2">5</span> Alpha-beta pruning (using iterators of iterators)</h2>
<div class="outline-text-2" id="text-5">
<p>
At this point, you can already play Tic-tac-toe with the computer. Just run <code>tic_tac_toe.play()</code>. However, the computer's response is a little slow. Let's speed it up.
</p>
</div>
</div>

<div id="outline-container-org9d33fe1" class="outline-2">
<h2 id="org9d33fe1"><span class="section-number-2">6</span> Appendix 1: Tic-tac-toe utilities</h2>
<div class="outline-text-2" id="text-6">
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;TIC_TAC_TOE_IMPORTS&gt;&gt;
&lt;&lt;TIC_TAC_TOE_UTILS&gt;&gt;
&lt;&lt;TIC_TAC_TOE_EVAL&gt;&gt;
&lt;&lt;TIC_TAC_TOE_TREE&gt;&gt;
&lt;&lt;TIC_TAC_TOE_PLAY&gt;&gt;
</pre>
</div>

<p>
These functions define the Tic-tac-toe game:
</p>
<div class="org-src-container">
<pre class="src src-python">### gameplay options
use_player_token = True
shuffle_moves = False
max_depth = 5

### board configuration and geometry
posinf = 100000
neginf = -1 * posinf

num_pos = 9
line_idx = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]

# Cell is a type alias for representing the state of a cell in a board
Cell = Optional[int]
# Board is a type alias for representing board configurations
Board = List[Cell]

def init_board() -&gt; Board:
    """Creat an empty board.
    An unoccupied position is represented by None"""
    board: List[Optional[int]] = [None for i in range(num_pos)]
    return board

def board_line(line_idx: List[int], board: Board) -&gt; List[Cell]:
    """Return a line (one of line_idx) of a board"""
    return [board[i] for i in line_idx]

def board_lines(board: Board) -&gt; List[List[Cell]]:
    """Return all the lines in a board"""
    return list(map(lambda idx: board_line(idx, board), line_idx))

def won(board: Board, player: int) -&gt; bool:
    """Has player won?"""
    assert player in [0, 1]
    lines = board_lines(board)

    if any(map(lambda l: l.count(player) == 3, lines)):
	return True
    else:
	return False

### Moves
def player_token(i: int) -&gt; str:
    assert i in [0, 1]
    if use_player_token:
	return "X" if i == 0 else "O"
    else:
	return "0" if i== 0 else "1"

def make_move(board: Board, move: int, current_player: int) -&gt; Board:
    """Apply a move (0-8) to a board for a player.
    Return a new board.
    """
    new_board = board.copy()
    assert new_board[move] is None
    assert current_player in [0, 1]

    new_board[move] = current_player

    return new_board

def who_plays(board: Board) -&gt; int:
    """Which player is playing the next move?"""
    return board.count(0) - board.count(1)

def moves(board: Board) -&gt; Optional[Iterator[Board]]:
    """Returns an iterator of boards for all legal next moves."""
    next_player = who_plays(board)
    other_player = (next_player + 1) % 2

    if won(board, other_player):
	# There is no legal move if the game is already won
	return None
    else:
	candidate_moves = [i for i in range(num_pos) if board[i] is None]

	if shuffle_moves:
	    shuffle(candidate_moves)

	if len(candidate_moves) == 0:
	    return None
	else:
	    return map(lambda i: make_move(board, i, next_player), candidate_moves)

def display_board(board: Board, coordinates = False) -&gt; None:
    """Display a board"""
    def row(lst):
	return reduce(lambda a, b: a + " "+ b, lst, "")

    d = {None: '.', 1: player_token(1), 0: player_token(0)}

    zz = list(map(lambda i: d[i], board))
    zz = [zz[i:i+3] for i in range(0, 9, 3)]
    zz = list(map(row, zz))

    if coordinates:
	def d_(i):
	    if board[i] is None:
		return str(i)
	    else:
		return "."
	zz2 = [d_(i) for i in range(9)]
	zz2 = [zz2[i:i+3] for i in range(0, 9, 3)]
	zz2 = list(map(row, zz2))

    res = ""
    if coordinates:
	for i in range(3):
	    res = res + zz[i] + "\t\t" + zz2[i] + "\n"
    else:
	for i in range(3):
	    res = res + zz[i] + "\n"

    print(res[:-1])
</pre>
</div>

<p>
Note that the player who plays the next move is not stored as a game state, because it can easily be inferred from the game board:
</p>
<div class="org-src-container">
<pre class="src src-python">def test_who_plays():
    b = init_board()
    assert who_plays(b) == 0

    b[1] = 0
    assert who_plays(b) == 1

    b[2] = 1
    assert who_plays(b) == 0
</pre>
</div>

<p>
<code>moves</code> is very important because it defines all the legal moves. Some basic testing is needed:
</p>
<div class="org-src-container">
<pre class="src src-python">def test_moves():
    # there should be no legal move for 0 because 1 has already won
    b = [1, 0, 0, 1, 0, None, 1, None, None]
    assert moves(b) is None

    # there should be no legal move for 0 because 0 has already won    
    b = [1, 0, 0, 1, 0, None, None, 0, 1]
    assert moves(b) is None

    # the board is full
    b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
    assert moves(b) is None
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdf2dded" class="outline-2">
<h2 id="orgdf2dded"><span class="section-number-2">7</span> Appendix 2: Static evaluation function for Tic-tac-toe</h2>
<div class="outline-text-2" id="text-7">
<p>
A static evaluation function takes a board configuration and returns a number representing how good the position is (without taking future moves into account). There are different ways to evaluate how good a configuration is. I implemented a common one.
</p>
<div class="org-src-container">
<pre class="src src-python">### Heuristic evaluation of board configurations
def is_good_line(n: int, player: int, line: List[Cell]) -&gt; bool:
    """A typical way to evaluate if a line is good"""

    assert n in [1, 2]
    assert player in [0, 1]

    v1 = line.count(player) == n
    v2 = line.count(None) == 3 - n
    return v1 and v2

def count_good_lines(n: int , player: int, lines: List[List[Cell]]) -&gt; int:
    """How many good lines?"""

    assert n in [1, 2]
    assert player in [0, 1]

    zz = list(map(lambda l: is_good_line(n, player, l), lines))
    return zz.count(True)

def static_eval_0(board: Board) -&gt; int:
    """Static board value for player 0
    &gt;0: player 0 is doing better
    &lt;0: player 1 is doing better
    """
    lines = board_lines(board)

    if any(map(lambda l: l.count(0) == 3, lines)):
	val = posinf
    elif any(map(lambda l: l.count(1) ==3, lines)):
	val = neginf
    else:
	x2 = count_good_lines(2, 0, lines)
	x1 = count_good_lines(1, 0, lines)

	o2 = count_good_lines(2, 1, lines)
	o1 = count_good_lines(1, 1, lines)

	val = 3 * x2 + x1 - (3 * o2 + o1)
    return val

def static_eval(i: int) -&gt; Callable[[Board], int]:
    """Static board value for player i"""
    assert i in [0, 1], i

    def static_eval_(board):
	v = static_eval_0(board)
	if i == 0:
	    return v
	else:
	    return -1 * v

    return static_eval_
</pre>
</div>

<p>
Using the <code>maptree</code> function defined in a , we can score an entire game! The following shows the distribution of the scores in a pruned tree:
</p>
<div class="org-src-container">
<pre class="src src-python">def test_static_eval():
    """Apply static eval to a game tree"""
    print("\n## test_static_eval2")
    def freq(lst):
	dict = {}
	for i in lst:
	    if i in dict:
		dict[i] = dict[i] + 1
	    else:
		dict[i] = 1
	return dict

    def show_freq(dict):
	k = dict.keys()
	k = sorted(k)
	for kk in k:
	    print(f'{kk:10}     {dict[kk]}')

    b0 = init_board()
    t = prune(gametree(b0))
    t = maptree(static_eval(0), t)
    t = list(tree_labels(t))
    show_freq(freq(t))
</pre>
</div>

<p>
It's important that the static evaluation function knows when a player wins the game.
</p>
<div class="org-src-container">
<pre class="src src-python">def test_static_eval_winning_condition():
    # evaluate for player 0
    eval_0 = static_eval(0)
    # evaluate for player 1
    eval_1 = static_eval(1)

    # player 0 won
    b = [1, 0, 0, 1, 0, None, None, 0, 1]
    assert eval_0(b) == posinf
    assert eval_1(b) == neginf

    # player 1 won
    b = [1, 0, 0, 1, 0, None, 1, None, None]
    assert eval_0(b) == neginf
    assert eval_1(b) == posinf
</pre>
</div>
</div>
</div>

<div id="outline-container-org20be616" class="outline-2">
<h2 id="org20be616"><span class="section-number-2">8</span> Appendix 3: The Tic-tac-toe gametree</h2>
<div class="outline-text-2" id="text-8">
<p>
Functions related to game AI (<code>gametree</code>, <code>prune</code>, <code>evaluate</code>) defined previously in the chapter are generic, and therefore require a couple of parameters to call. Here, we define Tic-tac-toe versions of these functions, to make them easier to use.
</p>
<div class="org-src-container">
<pre class="src src-python">gametree: Callable[[Board], Node] = game.gametree(moves)

def prune(tree: Node) -&gt; Node:
    return lazy_utils.prune(max_depth, tree)

# given a player, returns a tree evlauation function
def evaluate1(player: int) -&gt; Callable[[Board], int]:
    """Evaluate tic-tac-toe tree for player i (version 1)"""
    return game.evaluate1(gametree, static_eval(player), prune)

# given a tree evaluation function, return a function
# which takes a board and returns a board
def max_next_move(tree_eval_func: Callable[[Board], int]) -&gt; Callable[[Board], Optional[Board]]:
    return game.max_next_move(gametree, tree_eval_func)
</pre>
</div>

<p>
The winning conditions have to be reflected in the game tree. Let's make sure that they are:
</p>
<div class="org-src-container">
<pre class="src src-python">def test_game_tree_structure():
    # Since player 0 has won, there should be no subtrees
    b = [1, 0, 0, 1, 0, None, None, 0, 1]
    t = gametree(b)
    assert t[1] is None

    # Since player 1 has won, there should be no subtrees
    b = [1, 0, 0, 1, 0, None, 1, None, None]
    t = gametree(b)
    assert t[1] is None

    # This is a draw. There should be no subtrees
    b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
    t = gametree(b)
    assert t[1] is None
</pre>
</div>

<p>
The static evaluation function, when applied to the game tree, should also reflect the winning conditions.
</p>
<div class="org-src-container">
<pre class="src src-python">def test_gametree_evaluation():
    # player 0 has won
    b = [1, 0, 0, 1, 0, None, None, 0, 1]
    (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
    assert subtrees is None and score == posinf

    # player 1 has won
    b = [1, 0, 0, 1, 0, None, 1, None, None]
    (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
    assert subtrees is None and score == neginf

    # This is a draw
    b = [1, 0, 1, 0, 0, 1, 0, 1, 0]
    (score, subtrees) = maptree(static_eval(0), prune(gametree(b)))
    assert subtrees is None and score == 0
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcb55e10" class="outline-2">
<h2 id="orgcb55e10"><span class="section-number-2">9</span> Appendix 4: Testing the tree evaluation function</h2>
<div class="outline-text-2" id="text-9">
<p>
Test the tree evaluation function <code>evaluate1</code> on the most basic conditions:
</p>
<div class="org-src-container">
<pre class="src src-python">def test_tree_eval():
    b = [1, 0, 0, None, 0, None, 1, None, None]
    print("\nGiven this board, player 1 to play")
    player = 1
    display_board(b)

    print("\nThis move wins")
    b = [1, 0, 0, 1, 0, None, 1, None, None]
    display_board(b)
    score = evaluate1(player)(b)
    assert score == posinf

    print("\nThis move will lose in the next move, so should get a losing score")
    b = [1, 0, 0, None, 0, 1, 1, None, None]
    display_board(b)
    score = evaluate1(player)(b)
    assert score == neginf

    print("\nThis move will win in the next move, so should get a winning score")
    b = [1, 0, 0, None, 0, None, 1, 1, None]
    display_board(b)
    score = evaluate1(player)(b)
    assert score == posinf
</pre>
</div>
</div>
</div>

<div id="outline-container-org0614245" class="outline-2">
<h2 id="org0614245"><span class="section-number-2">10</span> Appendix 5: Gameplay</h2>
<div class="outline-text-2" id="text-10">
<p>
Here are some functions that are needed to actually play the game:
</p>
<div class="org-src-container">
<pre class="src src-python">def human_next_move(board: Board) -&gt; Optional[Board]:
    """Display current board, ask player to make the next move.
    Return a board after the player's move.
    """
    display_board(board, coordinates = True)
    legal_moves = [i for i in range(num_pos) if board[i] is None]
    if legal_moves == []:
	return None
    else:
	player = who_plays(board)

	ok = False
	while not ok:
	    m = input(f"player {player_token(player)} move?")
	    try:
		i = int(m)
		if i in legal_moves:
		    ok = True
	    except ValueError:
		pass

	return make_move(board, i, player) 

def computer_next_move(board: Board) -&gt; Optional[Board]:
    player = who_plays(board)
    computer_move_function = max_next_move(evaluate1(player))
    return computer_move_function(board)

def player_next_move(board: Board, player_settings = {0: 'human', 1: 'computer'}) -&gt; Optional[Board]:
    player = who_plays(board)
    if player_settings[player] == 'human':
	return human_next_move(board)
    else:
	return computer_next_move(board)
</pre>
</div>

<p>
The main game loop:
</p>
<div class="org-src-container">
<pre class="src src-python">def play(player_settings = {0: 'human', 1: 'computer'}) -&gt; None:
    b = init_board()

    finished = False
    while not finished:
	b = player_next_move(b, player_settings)
	player = (who_plays(b) + 1) % 2
	print()
	print(f"{player_token(player)} played:")
	display_board(b)
	print()

	assert b is not None
	if won(b, player):
	    print(f"{player_token(player)} won!")
	    finished = True
	elif len([i for i in range(num_pos) if b[i] is None]) == 0:
	    print("Draw!")
	    finished = True  
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd401942" class="outline-2">
<h2 id="orgd401942"><span class="section-number-2">11</span> Appendix 6: Misc</h2>
<div class="outline-text-2" id="text-11">
<div class="org-src-container">
<pre class="src src-python">def max_assoc(itr: Iterator[Tuple[Board, int]]) -&gt; Board:
    """Return the board with the highest score."""
    def max_f(new_item: Tuple[Board, int], old_item: Tuple[Board, int]):
	return new_item if new_item[1] &gt; old_item[1] else old_item

    first_item = next(itr)
    return reduce(max_f, itr, first_item)[0]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def test_max_assoc():
    data =[(["a"], 0), (["b"], -1), (["c"], 30), (["d", 20])]
    print(max_assic(iter(data)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org22243b0" class="outline-2">
<h2 id="org22243b0"><span class="section-number-2">12</span> Appendix 7: Imports</h2>
<div class="outline-text-2" id="text-12">
<div class="org-src-container">
<pre class="src src-python">from typing import List, Iterator, Callable, Optional
from functools import reduce
from random import shuffle

from lazy_utils import Node
import lazy_utils
import game
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">from functools import reduce
from typing import Callable, List, Iterator, Tuple, Optional
from lazy_utils import reptree, maptree, Node
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">from tic_tac_toe import init_board, moves, static_eval, display_board
from tic_tac_toe import who_plays, posinf, neginf, gametree, prune, evaluate1
from lazy_utils import tree_size, tree_depth, maptree, tree_labels
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hsin-Hao Yu</p>
<p class="date">Created: 2022-03-25 Fri 08:35</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
